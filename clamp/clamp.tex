\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
}
\usepackage{xurl}

\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}

\theoremstyle{definition}
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{observation}{Observation}
\newtheorem{note}{Note}
\newtheorem{hope}{Hope}
\newtheorem{warning}{Warning}
\newtheorem{problem}{Problem}
\newtheorem{fear}{Fear}
\newtheorem{question}{Question}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\A}{\mathbb{A}}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\MultiSet}{\mathrm{MultiSet}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{\texttt{d\_in}}
\newcommand{\dout}{\texttt{d\_out}}
\newcommand{\T}{\texttt{T}}
\newcommand{\Relation}{\mathrm{Relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\function}{\texttt{function}}
\newcommand{\float}{\texttt{float }}
\newcommand{\questionc}[1]{\textcolor{red}{\textbf{Question:} #1}}

\newcommand{\silvia}[1]{{ {\color{blue}{(silvia)~#1}}}}
\newcommand{\grace}[1]{{ {\color{purple}{(grace)~#1}}}}
\newcommand{\connor}[1]{{ {\color{teal}{(connor)~#1}}}}
\newcommand{\mike}[1]{{ {\color{green}{(mike)~#1}}}}
\newcommand{\todo}{{\textcolor{red}{TODO }}}


\title{Privacy Proofs for OpenDP: Clamping}
\author{S\'ilvia Casacuberta}
\date{June 2021}

\begin{document}

\maketitle

\section{Algorithm Implementation}
% OLD VERSION: The current OpenDP library contains two functions related to Clamping: \texttt{make\_clamp\_vec} and \texttt{make\_clamp\_sensitivity}. Both functions are contained in the file \texttt{manipulation.rs}. In this document, we are referring to the Clamping function \texttt{make\_clamp\_vec}.

% OLD VERSION: The current OpenDP library contains the \texttt{make\_clamp\_vec} function implementing the clamping function. This is defined in lines 68-80 of the file \texttt{clamp.rs} (\url{https://github.com/opendp/opendp/blob/21-impute/rust/opendp/src/trans/clamp.rs}).

\subsection{Code in Rust}
The current OpenDP library contains the \texttt{make\_clamp\_vec} function implementing the clamping function. This is defined in lines 25-38 of the file \texttt{manipulation.rs} in the Git repository\footnote{As of June 16, 2021. Since then, the code has been updated to include a more general clampable domain, which is not yet finished.} (\url{https://github.com/opendp/opendp/blob/58feb788ec78ce739caaf3cad8471c79fd5e7132/rust/opendp/src/trans/manipulation.rs#L25-L38}).

\begin{figure}[ht]
    \includegraphics[width=16cm]{clamp_rust.png}
    \centering
    \label{fig:code}
\end{figure}

% Change: go back to the previous Git push.
% TODO: add clamp sensitivity?

\subsection{Pseudocode in Python}\label{sec:pseudocode}
We present a simplified Python-like pseudocode of the Rust implementation below. The necessary definitions for the pseudocode can be found at \href{https://www.overleaf.com/project/60d215bf90b337ac02200a99}{``List of definitions used in the pseudocode"}.

\silvia{We could generalize the input domain below from float to a any general (unspecified) type that admits total ordering, and then add the corresponding precondition to assert that the type \texttt{T} for $L$ and $U$ has the trait \texttt{TotalOrd}. Note that partial ordering is not enough, and we might not be able to clamp in the domain. However, TotalOrd is still not implemented in the OpenDP library. For now, float is enough.}

\newpage

\subsubsection*{Preconditions}
To ensure the correctness of the output, we require the following preconditions:

\mike{The input metric can just be hardcoded to SymmetricDistance. This means there's no generic MI, so the precondition can be dropped} \silvia{Same for output metric, no? Also, wouldn't it be safer not to hardcode it in case more metrics are added to the library in the future?}
\mike{After recent talks, I think we're thinking this should go in the preconditions. We can expand the proof in the future if we get more metrics.} \silvia{Agreed}

\mike{The type T can be any type that implements PartialOrd- for example floats or ints}

\silvia{Fixed, but I think it should be ``implements TotalOrd", no?}
\mike{Yes ^^. I'm still seeing references to float throughout this document though. You should be able to just refer to T, where T is qualified by the trait bounds.} \silvia{Agreed}

\silvia{The domain/metric preconditions will be added once Prof. Vadhan agrees}

\begin{itemize}
    \item The type \texttt{T} must implement TotalOrd -- for example, \texttt{floats} or \texttt{ints}.
\end{itemize}

% Perhaps: change L for lower and U for upper
\begin{lstlisting}[language=Python, escapechar=|] 
def MakeClamp(L: T, U: T, metric): |\label{line:def}|
    if L > U: raise Exception('Invalid parameters') |\label{line:excep}|
    input_domain = VectorDomain(AllDomain(T))
    output_domain = VectorDomain(IntervalDomain(L, U))
    input_metric = SymmetricDistance()
    output_metric = SymmetricDistance()
    def stability_relation(d_in: u32, d_out: u32) -> bool:
        return d_out >= d_in*1
    
    def function(data: Vec(T)) -> Vec(T): |\label{line:fn}|
        def clamp(x: T) -> T: |\label{line:clamp}|
            return max(min(x, U), L)
        return list(map(clamp, data)) |\label{line:map}|
    return Transformation(input_domain, output_domain, function, input_metric, output_metric, stability_relation)
\end{lstlisting}

% Mike said: go back to float (so the GitHub version before the merge). Also: the end user chooses the metric. But the library will only allow 6 possible metrics (maybe expanded in the future): symmetric, hamming, $\ell_1$, $\ell_2$, max divergence, and smooth max divergence. So, in the case of clamping, the input metric can only be either symmetric or hamming. I should have a proof for each.

% Flipping $\din, \dout$: The worst case is equality. The relation accepts all greater distances. That's why the inequality is reversed. After chaining, the end-user can run a search (e.g., binary search) to tighten the $\dout$ down to the inequality.

\smallskip

%\silvia{If input metric equals output metric, do as above to avoid having to check that the end user passed them equal and raise exceptions?}

%\silvia{Stability relation and defining $\din, \dout$.}

%\silvia{Assuming it is ok to say bounded\_float?}

% Mike: "You can use the total ordering construction-time check to justify that min and max in your function work with the argument and won't fail"

% Also important: Programming framework setting $\mathcal{X} = \mathbb{R}$ is equivalent to $AllDomain<T>$ where $T$: Float.

\subsubsection*{Conditions as specified in the pseudocode}
\silvia{Redundant section with the pseudocode, but perhaps useful.}

\begin{itemize}
    \item \underline{Input domain:} domain of all vectors of elements of type \texttt{T}.\footnote{In the future, this will be changed to the domain of all vectors of elements from an arbitrary data domain implementing total ordering (more concretely, for a generic type \texttt{T} that must have traits \texttt{static, Clone,} and \texttt{TotalOrd}). However, this is not yet implemented in the OpenDP library.}
    \item \underline{Output domain:} domain of all vectors of elements in \texttt{IntervalDomain(L, U)}, where \texttt{L} and \texttt{U} are of type \T and stand for \textit{lower bound} and \textit{upper bound}, respectively.\footnote{The compiler infers \texttt{float} from the context, which is why it is omitted.}
    \item \underline{Function:} given $v$ of type \texttt{Vec(T)}, it returns a list where each vector entry $v_i$ has type \float and is equal to $\clamp(v_i)$, as defined in line \ref{line:clamp} of the pseudocode (Section~\ref{sec:pseudocode}).
    \item \underline{Input metric:} symmetric distance.\footnote{As of June 24, SubstituteDistance is no longer a metric part of the OpenDP library.}
    \item \underline{Output metric:} same as input metric (which have to be consistent -- this is checked by the preconditions).
    \item \underline{Stability relation:} for $\din, \dout$ of type \texttt{u32}, the relation returns $\True$ if and only if $\din \leq \dout$. In particular, clamping has stability parameter $c=1$.
\end{itemize}

More concisely, the stability relation can be stated as:\footnote{See page 14 of \textit{A Programming Framework for OpenDP} for more examples. Note that in the Rust implementation the metrics $d_{\X}$ and $d_{\Y}$ are \textit{not} inputs to the relation, and they are instead fixed as attributes of the transformation.}\silvia{Perhaps more concise: $\din, \dout \in$ \texttt{AllDomain<u32>}}
\begin{equation}\label{eq:relation}
    \textrm{Relation}(\din, \dout) = 
    \begin{cases} 
      \True & \textrm{if } \dout \geq \din \textrm{ for } \din, \dout \textrm{ of type } \texttt{u32} \\
      \False & \textrm{otherwise}
   \end{cases}
\end{equation}

\section{Proof}
\subsection{Symmetric Distance}
%\todo{Assumptions on min and max functions? Only min is defined in Rust, and assumes PartialOrd.}

%\todo{The carry type in Rust; e.g., bounded R is f32. But since it is bounded, it must be between L and U, but this does not follow from f32.} 

%\todo{Change theorem statement to include all needed  so that the theorems are claims about the constructors}

%\silvia{Reference specific lines in the pseudocode? E.g., for function.}
\begin{theorem}
    For every setting of the input parameters ($L, U$, metric) to \texttt{MakeClamp} such that the given preconditions
    hold, the transformation returned by \texttt{MakeClamp} has the following properties:
    \begin{enumerate}
        \item \textup{(Appropriate output domain).} For every vector $v$ in the input domain, $\function(v)$ is in the output domain. % Prof. Vadhan said on 29/6 to leave it as this for now, but maybe in the future we add to the theorem statement what exactly the input domain and output domain are (although of course we already say this in the proof)
        \item \textup{(Stability guarantee).} For every input $v,w$ of type \texttt{Vec(float)} and for every pair $(\din, \dout)$ (appropriately quantified), if $v,w$ are $d_{in}$-close under the symmetric distance metric and $\Relation(\din, \dout) = \True$, then $\function(v), \function(w)$ are $d_{out}$-close under the symmetric distance metric.
    \end{enumerate}
\end{theorem}

\begin{proof}
\textbf{(Appropriate output domain).} In the case of \texttt{MakeClamp}, this corresponds to showing that for every vector $v$ of type \texttt{Vec(T)}, $\function(v)$ is an element of \texttt{VectorDomain} \texttt{(IntervalDomain(L, U))}. For that, we need to show two things: first, that the vector entries of $\function(v)$ have type \T. % Recall that the compiler infers the float type from VectorDomain(IntervalDomain(L, U)) because L and U have type float
Second, that they belong to the interval $[L, U]$.

That $\function(v)$ has type \texttt{Vec(T)}  follows from the assumption that $v$ is in the input domain, the precondition requirement that \T has type \T, and the type signature of \texttt{function} in line~\ref{line:fn} of the pseudocode (Section~\ref{sec:pseudocode}), which takes in an element of type \texttt{Vec(T)} and returns an element of type \texttt{Vec(T)}. If the Rust code compiles correctly, then the type correctness follows from the definition of the type signature enforced by Rust. Otherwise, the code raises an exception for incorrect input type. Secondly, we need to show that the vector entries belong to the interval $[L, U]$. This follows from the definition of \texttt{clamp} in line \ref{line:clamp}. According to line \ref{line:clamp} in the pseudocode, there are 3 possible cases to consider:
\begin{enumerate}
    \item \texttt{x} $>$ $U$: then $\clamp$ returns $U$.
    \item \texttt{x} $\in [L, U]$: then $\clamp$ returns \texttt{x}.
    \item \texttt{x} $<$ $L$: then $\clamp$ returns $L$.
\end{enumerate}
In all three cases, the returned value of type \T is contained in the interval $[L, U]$. Hence by the returned vector as defined in line~\ref{line:map} of the pseudocode, $\function(v)$ is an element of the output domain \texttt{VectorDomain(IntervalDomain(L, U))}.

Lastly, the necessary condition that $L \leq U$ is checked in line~\ref{line:excep} of the pseudocode, hence correctness is guaranteed if no exception is raised. Both $L$ and $U$ have type \T by their precondition requirement. Both the definition of \texttt{IntervalDomain} and that of the \texttt{clamp} function (line~\ref{line:clamp} in the pseudocode, which uses the \texttt{min} and \texttt{max} functions) require that the type of $L, U$, and of each vector entry in $v$ admits a total ordering. In the case of \T, this holds by the preconditions.
\mike{floats don't have a total ordering. It only holds for non-null floats!}

%Next we show that the stability relation as defined in Equation~\eqref{eq:relation} yields a valid transformation. %\grace{Oh I think I understand now we assume $d_{in} \leq d_{out}$}

%\begin{lemma}[Soundness of the stability relation]\label{lemma:stability}
% Give it a name
%For every $(\din, \dout)$ pair, the function $\Relation(\din, \dout)$ returns $\False$ whenever there exists some $x$ such that $d_{\X}(x, x') \leq \din$ and $d_{\Y}(T(x), T(x')) > \dout$,
%where $T$ denotes the clamping transformation. %and $\Relation(\din, \dout)$ the clamping stability relation. % defined in pseudocode xx; specify where the Relation is defined better
%\end{lemma}

% Must show that the relation fails for every $(d_{in}, d_{out})$ pair where there exists some $x$ such that $d_{\mathcal{X}}(x, x') \leq d_{in}$ and $d_{\mathcal{Y}}(T(x), T(x')) > d_{out}$.

%\begin{proof}
%Since clamping is 1-stable, $d_{\Y}(T(x), T(x')) \leq d_{\X}(x, x')$ for all $x, x' \in \X$. (This is a recursive argument with Theorem 2! I think it has to go)
%\end{proof}
        
% MS EDIT1: I adjusted the statement to negate it-- the relation must fail for every pair that does not uphold the worst-case change in distances. It is fine for the relation to also fail for valid pairs-- there are many proofs out there that are not tight. Put another way, the relation need only fail everything that is not DP, it does not need to accept everything that is DP.

% Should "input parameters" be more specified?
% "appropriately quantified" sounds vague
%\grace{Why is this called privacy guarantee and not stability something? I thought it should only be a "privacy guarantee" for measurements not transformations.}
%\silvia{So ``privacy relation" for measurements $=$ ``stability relation" for transformations, but both are providing the DP guarantee. But maybe ``DP guarantee" is not the best name}

\textbf{(Stability guarantee).} Throughout the stability guarantee proof, we can assume that $\function(v)$ and $\function(w)$ are in the correct output domain, by the appropriate output domain property shown above. 

Since by assumption $\Relation(\din, \dout) = \True$, by the \texttt{MakeClamp} stability relation (as defined in Equation~\eqref{eq:relation}), we have that $\din \leq \dout$. Moreover, $v, w$ are assumed to be $\din$-close. By the definition of the symmetric difference metric, this is equivalent to stating that $d_{Sym}(v, w) = |\MultiSet(v) \Delta \MultiSet(w)| \leq \din$.

Further, applying the histogram notation,\footnote{See \textit{A Programming Framework for OpenDP}, footnote 1 in page 3. Note that there is a bijection between multisets and histograms, which is why the proof can be carried out with either notion. For further details, please consult \url{https://www.overleaf.com/project/60d214e390b337703d200982}.}  it follows that
\[
d_{Sym}(v, w) = \lVert h_{v} - h_{w}\rVert_1 = \sum_z |h_v(z) - h_w(z)| \leq \din \leq \dout.
\]
We now consider $\MultiSet(\function(v))$ and $\MultiSet(\function(w))$.
For each element $z \in \MultiSet(v) \cup \MultiSet(w)$, where $z$ has type \texttt{float}, if $z \in \MultiSet(v) \Delta \MultiSet(w)$, we will assume wlog that $z \in \MultiSet(v) \setminus \MultiSet(w)$. We consider the following cases:
%either $z \in \MultiSet(v) \cup \MultiSet(w)$ or $z \in \MultiSet(v) \Delta \MultiSet(w)$. In the former case, irregardless of whether $z \in [L, U]$ or $z>U, z<L$, element $z$ leaves $||h_v - h_w||_1$ invariant (by the definition of symmetric difference).

%In the latter case, assume wlog that $z \in \MultiSet(v)$ but $z \notin \MultiSet(w)$. We split the proof into three cases, and let $k$ be the multiplicity of $z$ in $\MultiSet(v)$.  
\begin{enumerate}
    \item $z > U$ or $z < L$: then, in the former case, $\clamp(z) = U$. First consider the case when $z \in \MultiSet(v) \cup \MultiSet(w)$ with the same multiplicity in both multisets. Then, $|h_{\function(v)}(z) - h_{\function(w)}(z)| = 0$ because we have both $h_{\function(v)}(z) = 0$ and $h_{\function(w)}(z) = 0$. Thus the sum
    \[
    \sum_z |h_{\function(v)}(z) - h_{\function(w)}(z)|
    \]
    remains invariant, because the quantity $|h_{v}(z) - h_{w}(z)|$ is added to $|h_{\function(v)}(U) - h_{\function(w)}(U)|$, given that $\clamp(z) = U$. 
    
    %\grace{Good explanation, especially w word invariant.}
    
    Suppose $z$ has multiplicity $k_v \geq 0$ in $\MultiSet(v)$ and multiplicity $k_w \geq 0$ in $\MultiSet(w)$, where $k_v \neq k_w$. After considering $z$, the value $h_{\function(v)}(U)$ becomes $h_{\function(v)}(U) + k_v$, and $h_{\function(w)}(U)$ becomes $h_{\function(w)}(U) + k_w$. Hence the quantity $|h_{\function(v)}(U) - h_{\function(w)}(U)|$ increases by at most $|h_v(z) - h_w(z)|$, since, by the triangle inequality,
    \[
         |(h_{\function(v)}(U) + k_v) - (h_{\function(w)}(U) + k_w)| \leq
    \]
    \[
         \leq |h_{\function(v)}(U) - h_{\function(w)}(U)| + |k_v - k_w| =
    \]
    \[
        = |h_{\function(v)}(U) - h_{\function(w)}(U)| + |h_v(z) - h_w(z)|.
    \]
    
    %It is only at most because if $h_{\clamp_{L, U}(v)}(U) < h_{\clamp_{L, U}(W)}(U)$ whenever $k_v > k_w$, or if $h_{\clamp_{L, U}(v)}(U) > h_{\clamp_{L, U}(W)}(U)$ whenever $k_v < k_w$
    %before considering this particular value of $z$, then after clamping $z > U$ their difference can shrink.
    
    %\[
     %   |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)| = |h_v(U) - h_w(U)| + |h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)|.
    %\]
    
    The same argument applies whenever $z < L$. 
    
    \silvia{The first subcase discussed here, i.e., when $k_v = k_w$, is also proven by the triangle inequality expression above, but it seemed clean to separate the case where the total sum remains invariant.}
    %Therefore, we conclude that, in this case,
    %\[
     %   ||h_{\clamp_{L, U}(v)} - h_{\clamp_{L, U}(w)}||_1 - |h_v(z) - h_w(z)|
     %\leq |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(v)}(U)|. 
    %\]
    
    \item $z \in (L, U)$: then, $\clamp(z) = z$. Since $h_v(z) = h_{\function(v)}(z)$ and $h_v(w) = h_{\function(w)}(z)$, it follows that $|h_v(z) - h_w(z)| = |h_{\function(v)}(z) - h_{\function(w)}(z)|$. Hence the histogram count, i.e., the quantity
     \[
        \sum_z |h_{\function(v)}(z) - h_{\function(w)}(z)|
    \]
    remains invariant.
    
    % \item $z \leq L$: then, $\clamp_{L, U}(z) = L$. Then, $\clamp_{L, U (v)}(z) = \clamp_{L, U (w)}(z) = U$, and hence $|h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)| = 0$.
    
    \item $z = U$ or $z = L$: then, in the former case, $\clamp(z) = U$. If $z \in \MultiSet(v) \cup \MultiSet(w)$ with the same multiplicity in both multisets, then the histogram count remains invariant under the addition of element $z$. Otherwise, if $z \in \MultiSet(v) \setminus \MultiSet(w)$, or if $z$ is in their union but with different multiplicity, then element $z$ can increase the quantity $|h_{\function(v)}(U) - h_{\function(w)}(U)|$ by at most $|h_v(z)-h_w(z)|$, following the same reasoning with the triangle inequality as in case~2.
    
    The same argument applies whenever $z = L$.
    % Probably simplify to add this case in the others.
\end{enumerate}

%\silvia{Make cases more concise; avoid repetitions (esp. to try to make proofs ``automatic")}

By aggregating the three cases above, we conclude that
\[
\sum_z |h_{\function(v)}(z) - h_{\function(w)}(z)| \leq \sum_z |h_v(z) - h_w(z)|.
\]
By the initial assumptions, we recall that $\din \leq \dout$, and that $v, w$ are $\din$-close. Then,
\[
\sum_z |h_{\function(v)}(z) - h_{\function(w)}(z)| \leq \sum_z |h_v(z) - h_w(z)| \leq \din \leq \dout.
\]
Therefore, 
\[
|\MultiSet(\function(v)) \Delta \MultiSet(\function(w))| \leq \dout,
\]
as we wanted to show.
\end{proof}

\silvia{Maybe add domain of $z$ below the sum?}
%\grace{Great, very rigorous}
% correct domains above?

% More proofs? Mike: Most proofs give conditions for which they are valid on. This mostly captures domains and metrics. You need a proof for the relation-- the function pseudocode, domains and metrics are all necessary to qualify the proof. I guess it may also make sense to have a proof for the output domain.

% Not sure: separate into vec and sensitivity?

\newpage

OLD VERSION BEFORE PROF. VADHAN'S CORRECTIONS -- IGNORE

\section{Preliminaries}
We recall that a transformation $T$ is a \textit{deterministic} mapping from \textit{datasets} to \textit{datasets}. In Rust, a Transformation is specified by the following attributes: input domain, output domain, function, input metric, output metric, and stability relation.

For $c \in \R$, we say that $T$ is $c$\textit{-stable} if for all datasets $x, x'$ in the input domain,
\begin{equation}
    d_{\mathcal{Y}}(T(x), T(x')) \leq c \cdot d_{\mathcal{X}}(x, x').
\end{equation}

The \textit{metrics} $d_{\X}, d_{\Y}$ (i.e., functions that return the distance between each pair of points in a set) should not be mistaken with the actual distances $\din, \dout$. In other words, the type of the evaluation of the $\X(\cdot)$ function is equal to the type of $\din$, and the type of the evaluation of the $\Y(\cdot)$ function is equal to the type of $\dout$.

%[define $\din, \dout$]

We refer to $c$ as the \textit{stability parameter}. In turn, the value $c$ should not be mistaken with the stability relation, which is a relation property between $\din, \dout$. For example, if the relation between $\din, \dout$ is specified as $\din \leq \dout$, then $\Relation(\din, \dout)$ returns \texttt{true} if and only if $\din \leq \dout$. Moreover, the end user can empirically find the stability value $c$ (i.e., the tightest bound) by querying multiple times with different $(\din, \dout)$ pairs in a binary search manner, and adaptively modifying them given the \texttt{true, false} answers returned by the stability relation. We will explore this relation further as well as the notion of $d_{mid}$ when considering chaining. 

We also remark that in the OpenDP library, the relation between $\din, \dout$ can (and will) be overestimated, and can only accept the worst-case or ``global" privacy degradation over that transformation. In the case of measurements, the stability relation is replaced by the \textit{privacy relation}, but we are not concerned with measurements in this document.
% avoiding name confusions

\section{Algorithm Implementation}
% OLD VERSION: The current OpenDP library contains two functions related to Clamping: \texttt{make\_clamp\_vec} and \texttt{make\_clamp\_sensitivity}. Both functions are contained in the file \texttt{manipulation.rs}. In this document, we are referring to the Clamping function \texttt{make\_clamp\_vec}.

% OLD VERSION: The current OpenDP library contains the \texttt{make\_clamp\_vec} function implementing the clamping function. This is defined in lines 68-80 of the file \texttt{clamp.rs} (\url{https://github.com/opendp/opendp/blob/21-impute/rust/opendp/src/trans/clamp.rs}).

\subsection{Code in Rust}
The current OpenDP library contains the \texttt{make\_clamp\_vec} function implementing the clamping function. This is defined in lines 25-38 of the file \texttt{manipulation.rs} in the Git repository\footnote{As of June 16, 2021.} (\url{https://github.com/opendp/opendp/blob/main/rust/opendp/src/trans/manipulation.rs#L25-L38}).
\mike{This is pretty dated now. Would be good to get an updated version with the AbsoluteDistance clamping. I'm happy to explain how this works.}

\begin{figure}[ht]
    \includegraphics[width=16cm]{clamp_rust.png}
    \centering
    \label{fig:code}
\end{figure}

% Change: go back to the previous Git push.
% TODO: add clamp sensitivity?

\subsection{Function Definition}
In clamping, the input data domain $\mathcal{X}$ is $\R$ % not necessarily! Why are we imposing R? 
and the output data domain $\mathcal{Y}$ is $[L, U]$, where $L, U \in \X = \R$. In the OpenDP library, domain $\R$ corresponds to \texttt{AllDomain<T>}, where \texttt{T: Float}.

The function \texttt{clamp}$_{L, U}: \mathcal{X} \rightarrow \mathcal{Y}$ is defined as:
\begin{equation}\label{eq:clamp}
\texttt{clamp}_{L, U}(z) = 
\begin{cases} 
      U & \textrm{if } z > U \\
      z & \textrm{if } z \in [L, U] \, . \\
      L & \textrm{if } z < L
\end{cases}
\end{equation}
Then, we can define the transformation $T: \textrm{MultiSets}(\mathcal{X}) \rightarrow \textrm{MultiSets}(\mathcal{Y})$, which we will show to be 1-stable, under the symmetric difference metric or under the Hamming distance metric can be defined by: % and without? Is it necessarily 1?
\[
T(x) = \{\textrm{clamp}_{L, U}(z) : z \in x \}.
\]

Note that while the clamp function might admit other metrics, the OpenDP library currently only implements symmetric difference and Hamming distance for database metrics, which is why we restrict ourselves to them in this document.

\subsection{Pseudocode in Python}
We present a simplified Python-like pseudocode of the Rust implementation below.

\begin{lstlisting}[language=Python]
class Transformation:
    input_domain
    output_domain
    function
    input_metric
    output_metric
    stability_relation 

def MakeClamp(L: float, U: float, metric):
    if L > U: raise Exception('Invalid parameters')
    input_domain = vector(float) 
    output_domain = IntervalDomain(L, U, float)
    input_metric = metric
    output_metric = metric
    assert isinstance(metric, SymmetricDifference or HammingDistance)
    stability_relation = lambda(d_in, d_out) : d_in <= d_out
    
    def function(data):
        def clamp(x): return max(min(x, U), L)
        return map(clamp, data) 
    return Transformation(input_domain, output_domain, function, input_metric, output_metric, stability_relation)

# Example: suppose we are interested in the 
# number of entries in a vector of integers or floats:
Clamping = MakeClamp(l, u, SymmetricDifference)

# We could also use a different metric:
Clamping = MakeClamp(l, u, HammingDistance)
\end{lstlisting}

% Mike said: go back to float (so the GitHub version before the merge). Also: the end user chooses the metric. But the library will only allow 6 possible metrics (maybe expanded in the future): symmetric, hamming, $\ell_1$, $\ell_2$, max divergence, and smooth max divergence. So, in the case of clamping, the input metric can only be either symmetric or hamming. I should have a proof for each.

% Flipping $\din, \dout$: The worst case is equality. The relation accepts all greater distances. That's why the inequality is reversed. After chaining, the end-user can run a search (e.g., binary search) to tighten the $\dout$ down to the inequality.

\smallskip

%\silvia{If input metric equals output metric, do as above to avoid having to check that the end user passed them equal and raise exceptions?}

%\silvia{Stability relation and defining $\din, \dout$.}

%\silvia{Assuming it is ok to say bounded\_float?}

In the Rust code, the stability parameter $c$ (which in the case of clamping is equal to~1) gets wrapped up inside of the stability relation property, and the end user could test it empirically.

\silvia{We could generalize the input domain above from float to a any general (unspecified) type that admits total ordering, and then add the line \texttt{assert\_has\_trait(L, TotalOrdering} to the pseudocode, and similarly for $U$).}

% Mike: "You can use the total ordering construction-time check to justify that min and max in your function work with the argument and won't fail"

% Also important: Programming framework setting $\mathcal{X} = \mathbb{R}$ is equivalent to $AllDomain<T>$ where $T$: Float.

\subsubsection*{Conditions as specified in the pseudocode}

\begin{itemize}
    \item \underline{Input domain:} vectors of elements of an arbitrary data domain which implement PartialOrd ($=$ partial ordering).\footnote{In the future, OpenDP should be implementing Ord (ordering) and not PartialOrd, but we work with the current implementation. The difference is that PartialOrd does not guarantee that every pair of elements in the data domain is comparable.} That is, such data domain must admit a binary relation $\leq$ such that for all $a, b, c$ in this data domain, it satisfies:
    \begin{enumerate}
        \item Reflexivity ($a \leq a$),
        \item Antisymmetry (if $a \leq b$ and $b \leq a$ then $a=b$,
        \item Transitivity (if $a \leq b$ and $b \leq c$ then $a \leq c$).
    \end{enumerate}
    In OpenDP, such data domain consists primarily of ints and floats, which is why we specify floats above (more concretely, we allow f32/64).
    \item \underline{Output domain:} vectors of elements of the input domain specified above but with the additional restriction of being contained within the interval $[L, U]$, where $L, U$ are elements of $\X$.
    \item \underline{Function:} returns vector mapping where each vector element $v$ equals $\texttt{clamp(v)}$ as specified in Equation \eqref{eq:clamp}.
    \item \underline{Input metric:} symmetric difference or Hamming distance. 
    \begin{itemize}
        \item Symmetric difference: For any two datasets $v, u$, we say that $v, u$ are $d$-close in symmetric difference if $d_{Sym}(u, v) = |\textrm{MultiSets}(v) \Delta \textrm{MultiSets}(u)| \leq d$. The symmetric difference between $\textrm{MultiSets}(u), \textrm{MultiSets}(v)$ is the set of elements, or rows, that appear in either $\textrm{MultiSets}(u)$ or $\textrm{MultiSets}(v)$ but \textit{not} in their intersection. 
        %Change to $d_{Sym}(?)$. 
        \item Hamming distance: For any two vectors $v, u$, we say that $v, u$ are $d$-close in hamming distance if $d_{Ham}(v, u) \leq d$. The Hamming distance between two vectors $v, u$ is the number of places where $u$ and $v$ differ. Thus the Hamming distance between two vectors is the number of bits we must change to transform one vector into the other. The desired Hamming notion for the OpenDP library has not yet been decided, and so for now we do not include it in the proof.
    \end{itemize}
    
    % I am not convinced that this is the correct domain usage
    % It does not make sense to say MultiSet(v) because v is a vector and this should be a dataset instead
    \item \underline{Output metric:} same as input metric (which have to be consistent).
    \item \underline{Stability relation:} for the two 32-integer bits $d_{in}, d_{out}$, we return $\True$ if $d_{in} \leq d_{out}$. In particular, clamping has stability parameter $c=1$. \\\
\end{itemize}

More formally, the stability relation can be stated as:\footnote{See page 14 of \textit{A Programming Framework for OpenDP} for more examples. Moreover, in the actual Rust implementation the metrics $d_{\X}$ and $d_{\Y}$ are \textit{not} inputs to the relation, and they are instead fixed as attributes of the transformation.}
\begin{equation}
    R((d_{\X}, \din), (d_{\Y}, \dout)) = 
    \begin{cases} 
      \True & \textrm{if } d_{\X} = d_{\Y} = d_{Sym} \, \din, \dout \in \Z, \dout \geq \din \\
      \True & \textrm{if } d_{\X} = d_{\Y} = d_{Ham}, \, \din, \dout \in \Z, \dout \geq \din \, . \\
      \False & \textrm{otherwise}
   \end{cases}
\end{equation}

Importantly, such relations are sound but \textit{not necessarily complete}. A transformation is considered \textit{valid} if its stability relation is sound.

\section{Proof}
\subsection{Symmetric Difference}
\begin{theorem}[Appropriate output domain]
    For every vector $v$ in the input domain, \texttt{clamp}($v$) is in the output domain. That is, \texttt{clamp}$_{L, U}(v) \in \texttt{bounded\_float}(L, U)$. % or data_domain?
\end{theorem}

\begin{proof}
This follows directly from the definition of the \texttt{clamp} function in Equation \eqref{eq:clamp} and line 19 in the pseudocode of Section~\ref{sec:pseudocode}. \silvia{Detail more?}
\end{proof}

% Also, $L, U$ need to be elements of the input domain, no? Is this being checked? That $L \leq U$ is already checked in the pseudocode.

The necessary condition that $L \leq U$ is already checked in the pseudocode, hence correctness is guaranteed. 

\medskip

Next we show that the stability relation as defined in Equation~\eqref{eq:relation} yields a valid transformation. %\grace{Oh I think I understand now we assume $d_{in} \leq d_{out}$}

%\begin{lemma}[Soundness of the stability relation]\label{lemma:stability}
% Give it a name
%For every $(\din, \dout)$ pair, the function $\Relation(\din, \dout)$ returns $\False$ whenever there exists some $x$ such that $d_{\X}(x, x') \leq \din$ and $d_{\Y}(T(x), T(x')) > \dout$,
%where $T$ denotes the clamping transformation. %and $\Relation(\din, \dout)$ the clamping stability relation. % defined in pseudocode xx; specify where the Relation is defined better
%\end{lemma}

% Must show that the relation fails for every $(d_{in}, d_{out})$ pair where there exists some $x$ such that $d_{\mathcal{X}}(x, x') \leq d_{in}$ and $d_{\mathcal{Y}}(T(x), T(x')) > d_{out}$.

%\begin{proof}
%Since clamping is 1-stable, $d_{\Y}(T(x), T(x')) \leq d_{\X}(x, x')$ for all $x, x' \in \X$. (This is a recursive argument with Theorem 2! I think it has to go)
%\end{proof}
        
% MS EDIT1: I adjusted the statement to negate it-- the relation must fail for every pair that does not uphold the worst-case change in distances. It is fine for the relation to also fail for valid pairs-- there are many proofs out there that are not tight. Put another way, the relation need only fail everything that is not DP, it does not need to accept everything that is DP.

% Should "input parameters" be more specified?
% "appropriately quantified" sounds vague
%\grace{Why is this called privacy guarantee and not stability something? I thought it should only be a "privacy guarantee" for measurements not transformations.}
%\silvia{So ``privacy relation" for measurements $=$ ``stability relation" for transformations, but both are providing the DP guarantee. But maybe ``DP guarantee" is not the best name}
\begin{theorem}[Stability guarantee]
    For every setting of the input parameters to \texttt{MakeClamp}, the transformation produced
    has the following property:
    For every $v,w$ in the input domain and for every pair $(d_{in}, d_{out})$ (appropriately quantified), if 
    %$\Relation(d_{in},d_{out}) = \texttt{True}$ and 
    $v,w$ are $d_{in}$-close and $\Relation(\din, \dout) = \True$, then $\clamp_{L, U}(v), \clamp_{L, U}(w)$ are $d_{out}$-close. % clamp or function? Technically, clamp(v)is not encoding the metrics, etc.
\end{theorem} % I take out the Relation = true assumption because now this is encoded in Lemma 1

% I should maybe add L, U as subindices of clamp

\begin{proof}
Since by assumption $\Relation(\din, \dout) = \True$, by the clamping stability relation (Equation~\eqref{eq:relation}) we have that $\din \leq \dout$. Moreover, $v, w$ are assumed to be $\din$-close. By the definition of the symmetric difference metric, this is equivalent to stating that $d_{Sym}(v, w) = |\MultiSet(v) \Delta \MultiSet(w)| \leq d_{in}$.

For any data domain $\mathcal{X}$, a dataset $x \in \textrm{MultiSets}(\mathcal{X})$ can be specified by its histogram $h_x : \mathcal{X} \rightarrow{\mathbb{N}}$, where $h_x(z)$ denotes the number of occurrences of $z$ in $\mathcal{X}$.\footnote{\textit{A Programming Framework for OpenDP}, footnote 1 in page 3. Note that there is a bijection between multisets and histograms, which is why the proof can be carried out with either notion.} 
\silvia{I do not fully agree with the notation used in the Programming Framework (PF) for the histograms. Is it not the number of occurrences of $z$ in $x \in \MultiSet(\X)$?}

Then, it follows that
\[
|\textrm{MultiSets}(v) \Delta \textrm{MultiSets}(w)| = \lVert h_{v} - h_{w}\rVert_1 = \sum_z |h_v(z) - h_w(z)|. 
\]
\silvia{The above notation for the symmetric difference is also not ideal because while we want to mean that we regard the input vector as a multiset (i.e., with no ordering), $\MultiSet(v)$ would really mean a multiset of vector records, according to the PF. So we should agree on whether we write $|\MultiSet(v) \Delta \MultiSet(w)|$ or $|v \Delta w|$.}

That is, the symmetric distance between $v$ and $w$ is equal to the $\ell_1$ distance between $h_v$ and $h_w$ (histogram notation).\footnote{This is because the symmetric difference between two databases $X, X'$ is the set of elements, or rows, that appear in either $X$ or $X'$ but \textit{not} in their intersection.} The second equality above applies the definition of $\ell_1$ distance. By putting the above observation together with the stability relation, we obtain that
\[
\sum_z |h_v(z) - h_w(z)| \leq d_{in} \leq d_{out}.
\]
% now I want to relate h_v to clamp_v
We now consider $\MultiSet(\clamp_{L, U}(v))$ and $\MultiSet(\clamp_{L, U}(w))$.
For each element $z \in \MultiSet(v) \cup \MultiSet(w)$, if $z \in \MultiSet(v) \Delta \MultiSet(w)$, we will assume wlog that $z \in \MultiSet(v) \setminus \MultiSet(w)$. We consider the following cases:
%either $z \in \MultiSet(v) \cup \MultiSet(w)$ or $z \in \MultiSet(v) \Delta \MultiSet(w)$. In the former case, irregardless of whether $z \in [L, U]$ or $z>U, z<L$, element $z$ leaves $||h_v - h_w||_1$ invariant (by the definition of symmetric difference).

%In the latter case, assume wlog that $z \in \MultiSet(v)$ but $z \notin \MultiSet(w)$. We split the proof into three cases, and let $k$ be the multiplicity of $z$ in $\MultiSet(v)$.  
\begin{enumerate}
    \item $z > U$ or $z < L$: then, in the former case, $\clamp_{L, U}(z) = U$. First consider the case when $z \in \MultiSet(v) \cup \MultiSet(w)$ with the same multiplicity in both multisets. Then, $|h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)| = 0$ because we have both $h_{\clamp_{L, U}(v)}(z) = 0$ and $h_{\clamp_{L, U}(w)}(z) = 0$. Thus the sum
    \[
    \sum_z |h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)|
    \]
    remains invariant, because the quantity $|h_{v}(z) - h_{w}(z)|$ is added to $|h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)|$, given that $\clamp_{L, U(v)}(z) = \clamp_{L, U (w)}(z) = U$. 
    
    \grace{Good explanation, especially w word invariant.}
    
    Suppose $z$ has multiplicity $k_v \geq 0$ in $\MultiSet(v)$ and multiplicity $k_w \geq 0$ in $\MultiSet(w)$, where $k_v \neq k_w$. Then after considering $z$, the value $h_{\clamp_{L, U}(v)}(U)$ becomes $h_{\clamp_{L, U}(v)}(U) + k_v$, and $h_{\clamp_{L, U}(w)}(U)$ becomes $h_{\clamp_{L, U}(v)}(U) + k_w$. Hence the quantity $|h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)|$ increases by \textit{at most} $|h_v(z) - h_w(z)|$, since, by the triangle inequality,
    \[
         |(h_{\clamp_{L, U}(v)}(U) + k_v) - (h_{\clamp_{L, U}(w)}(U) + k_w)| \leq
    \]
    \[
         \leq |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)| + |k_v - k_w| =
    \]
    \[
        = |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)| + |h_v(z) - h_w(z)|.
    \]
    
    %It is only at most because if $h_{\clamp_{L, U}(v)}(U) < h_{\clamp_{L, U}(W)}(U)$ whenever $k_v > k_w$, or if $h_{\clamp_{L, U}(v)}(U) > h_{\clamp_{L, U}(W)}(U)$ whenever $k_v < k_w$
    %before considering this particular value of $z$, then after clamping $z > U$ their difference can shrink.
    
    %\[
     %   |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)| = |h_v(U) - h_w(U)| + |h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)|.
    %\]
    
    The same argument applies whenever $z < L$. 
    
    \silvia{The first subcase discussed here, i.e., when $k_v = k_w$, is also proven by the triangle inequality expression above, but it seemed clean to separate the case where the total sum remains invariant.}
    %Therefore, we conclude that, in this case,
    %\[
     %   ||h_{\clamp_{L, U}(v)} - h_{\clamp_{L, U}(w)}||_1 - |h_v(z) - h_w(z)|
     %\leq |h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(v)}(U)|. 
    %\]
    
    \item $z \in (L, U)$: then, $\clamp_{L, U}(z) = z$. Since $h_v(z) = h_{\clamp_{L, U}(v)}(z)$ and $h_v(w) = h_{\clamp_{L, U}(w)}(z)$, it follows that $|h_v(z) - h_w(z)| = |h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)|$. Hence the histogram count, i.e., the quantity
     \[
        \sum_z |h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)|
    \]
    remains invariant.
    
    % \item $z \leq L$: then, $\clamp_{L, U}(z) = L$. Then, $\clamp_{L, U (v)}(z) = \clamp_{L, U (w)}(z) = U$, and hence $|h_{\clamp_{L, U}(v)}(z) - h_{\clamp_{L, U}(w)}(z)| = 0$.
    
    \item $z = U$ or $z = L$: then, in the former case, $\clamp_{L, U}(z) = U$. If $z \in \MultiSet(v) \cup \MultiSet(w)$ with the same multiplicity in both multisets, then the histogram count remains invariant under the addition of element $z$. Otherwise, if $z \in \MultiSet(v) \setminus \MultiSet(w)$, or if $z$ is in their union but with different multiplicity, then element $z$ can increase the quantity $|h_{\clamp_{L, U}(v)}(U) - h_{\clamp_{L, U}(w)}(U)|$ by at most $|h_v(z)-h_w(z)|$, following the same reasoning with the triangle inequality as in case 2.
    
    The same argument applies whenever $z = L$.
    % Probably simplify to add this case in the others.
\end{enumerate}

%\silvia{Make cases more concise; avoid repetitions (esp. to try to make proofs ``automatic")}

By aggregating the three cases above, we conclude that
\[
\sum_z |h_{\texttt{clamp}(v)}(z) - h_{\texttt{clamp}(w)}(z)| \leq \sum_z |h_v(z) - h_w(z)|.
\]
By the initial assumptions, we recall that $\din \leq \dout$, and that $v, w$ are $\din$-close. Then,
\[
\sum_z |h_{\texttt{clamp}(v)}(z) - h_{\texttt{clamp}(w)}(z)| \leq \sum_z |h_v(z) - h_w(z)| \leq \din \leq \dout.
\]
Therefore, 
\[
|\MultiSet(\clamp_{L, U}(v)) \Delta \MultiSet(\clamp_{L, U}(w))| \leq \dout,
\]
as we wanted to show.

\end{proof}
\silvia{Maybe add domain of $z$ below the sum}
\grace{Great, very rigorous}
% correct domains above?

% More proofs? Mike: Most proofs give conditions for which they are valid on. This mostly captures domains and metrics. You need a proof for the relation-- the function pseudocode, domains and metrics are all necessary to qualify the proof. I guess it may also make sense to have a proof for the output domain.

% Not sure: separate into vec and sensitivity?

\subsection{Hamming Distance}
%(All the same, but reproduce for the sake of completeness.)
The same proof as for symmetric difference holds. However, we await to write it out formally until the precise notion of Hamming distance (i.e., whether ordering wants to be preserved in the multiset or not) is encoded in the library.

%\newpage

\section{Past Resolved Confusions}
\subsection{The Flipping of $\din, \dout$}
That a transformation $T$ is $c$-stable is a property of the function, not of the relation. The stability relation is a claim about the transformation, namely:

\begin{definition}
Given a transformation $T$, a stability relation $R$ is \textit{valid} for $T$ with respect to ``metrics"\footnote{In fact, $d_{\X}$ are not required to be actual metrics (in the usual mathematical definition). Nonetheless, certain metric properties such as the triangle inequality might be necessary for certain later DP properties; e.g., group privacy.} $d_{\X}$ and $d_{\Y}$ if and only if $\forall x, x'$ in the input domain $\X$ and $\forall \din, \dout$ such that $\Relation(\din, \dout) = \True$, if $x, x'$ are $\din$-close with respect to $d_{\X}$, then $T(x), T(x')$ are $\dout$-close with respect to $d_{\Y}$.
\end{definition}

So the way to think about this is as follows: first, we imagine the transformation without the relation (i.e., the function and the corresponding domains and metrics). Then we find the stability parameter between $d_{\X}, d_{\Y}$; i.e., the parameter $c$ such that $d_{\Y}(T(x), T(x')) \leq c \cdot d_{\X}(x, x')$ $\forall x, x'$. Then, because the stability relation has to be sound (but not complete), we establish the stability relation to be $\Relation(\din, \dout) = \True$ if $\din \leq c \cdot \dout$. Note that the inequality sign flips. This is because the implication
\begin{center}
    If $d_{\X}(x, x') \leq \din$, then $d_{\Y}(T(x), T(x')) \leq \dout$
\end{center}
holds if (and not if and only if) 
\[
\dout \geq c \cdot \din,
\]
given that, in this case,
\[
d_{\Y}(T(x), T(x')) \leq c \cdot d_{\X}(x, x') \leq c \cdot \din \leq \dout.
\]
Only after this has been proven do we add the stability relation to the code.

\subsection{Sets, Vectors, and Metrics}
In the OpenDP Programming Framework, datasets are represented as a multiset of records. Therefore, by the definition of a set, there is no ordering. While such multisets are represented as domains of vectors in the OpenDP library, this does \textit{not} imply that these vectors are adding any notion of order to the set. For Hamming distance, we need to decide whether we stick with the usual definition, or whether we allow permutations (``semi-Hamming"). In the latter, between the symmetric difference and ``semi-Hamming", only the data domain would change, and the two metrics would yield distances always a factor of 2 apart.

\subsection{Forward and Backward Maps}
Mike explanation on the stability relation in Rust: the internals of StabilityRelation actually contain up to three closures: the relation itself, as well as an optional forward map, and an optional backward map. The maps translate a distance in one space to another. For StabilityRelations constructed from \texttt{new\_from\_constant}, the forward map is automatically constructed and is essentially $|\din| c * \din$.\footnote{Notation: when he writes $|\din| \, c * \din$ he means $\textrm{forward\_map}(\din) = c * \din$.}

When the composed relation is checked, the integrity of the relation is upheld by the mandatory relation closure. The maps that may come bundled inside StabilityRelation are used to construct hinters: if a forward map exists, the hint is $|\din, \dout| \, \textrm{forward\_map}(\din)$, which of course simplifies to $d_{mid} = c * \din$ if chaining with a $c$-stable transformation. Not all forward maps are as simple as $c * \din$.

So then you have \texttt{StabilityRelation::new\_from\_constant(1u32))}, which makes a relation $|\din, \dout| \, \dout \geq 1 * \din$, that also contains a forward map $|\din|\, 1 * \din$, and a backward map $|\dout| \, \dout / 1$. This behaves as any 1-stable transformation would: when tight, the transformation does not increase the distance between datasets.


The forward map translates a distance in the input space to a distance in the output space. So that closure takes one argument, a distance in the input space. Then it translates it to a distance in the output space by multiplying $\din$ by $c$. When chaining two relations, you can use the forward map on the first relation to get $d_{mid}$. If the first relation does not have the optional forward map, check if the second relation has a backward map, and if so use it to construct a hinted $d_{mid}$ from $\dout$. It is notation for a closure; the stuff in the pipes are the arguments, and the stuff after the pipes is the function body.

%\section{Unification of the Proofs}
%Towards an ``automatic verification" of the proofs. Here is the beginning of a ``cook book" for providing proofs in the OpenDP library:
%\begin{itemize}
    %\item ...
%\end{itemize}

\section{Further Comments/Questions -- (Resolved after 16/6 meeting)}
\begin{itemize}
    \item Unification of proofs: agreeing on the class attributes in the pseudocode and in the proof elements. Should the stability parameter be part of the pseudocode? Minor: float vs f32/f64 (see my pseudocode above). And include Example with actual metrics in the pseudocode?
    \item \textbf{Important.} Proof elements: (perhaps correct output domain), the stability relation is sound, and $\din$ plus stability relation being true implies $\dout$ (DP guarantee). 
    \begin{itemize}
        \item \underline{Assuming vs proving the $\din, \dout$ stability relation} (Excel column). Different relations are possible (because they are not required to be tight; completeness is not necessary), but for the transformation to be valid they have to be sound. 
        \item Rephrasing: what we have all done is: assume $input \leq \din$ and $\din \leq \dout$ (so assume relation). Then, we want to show that $output \leq \dout$. To do so, our three proofs do: we show that $output \leq input$, because then $output \leq input \leq \din \leq \dout$. But showing $output \leq input$ is precisely what justifies using the stability relation $\din \leq \dout$. Recursive argument? (Should not assume Excel columns, they should be proven)
        \item Formal definition of $\din, \dout$.
        \item What the PF says on page 12 is not coherent with the above. Page 14 is though.
        \item The flipping inequality of the $\din, \dout$, and relation to $d_{\X}$ and $d_{\Y}$, respectively.
        \item Relationship to $\epsilon$ and sensitivity.
        \item Base Laplace proof \textit{fixes} $\din, \dout$. %I think there they are mixing up $d_{\X}$ with $\din$, because $\ell_1$ sensitivity is the metric.
    \end{itemize}
    \item \textbf{Relevant.} I think we are all making mistakes with vectors vs datasets vs MultiSets when discussing $d_{Sym}, d_{Ham}$. Because Rust takes in a vector when we are talking about a dataset. Symmetric difference is for datasets; Hamming is for vectors. And for histogram: \underline{where does $z$ belong to?} (E.g., clamping: there is a difference between it being 0 and $z$ just not being part of the considered domain). In this line of question, in the Excel sheet some transformations have both symmetric and Hamming, and some only have symmetric. Why? And those that have both symmetric and Hamming, how can they have the same domain if set $\neq$ vector? Lastly, count is using a reasoning based on rows, so again important to be clear on what is a vector and what is a dataset (vectors do not have rows). I think there are also some confusions in the proofs with $x$ vs $\X$.
    \item Independence of the stability relation from the end user input metric. This is how we all have it now in the pseudocode, but this is not coherent with PF page 14.
    \item Using histogram notation (Grace has the same question). Histogram notation for other metrics outside of symmetric difference? (E.g., Hamming).
    \item Connor and Grace show that their input/output relation holds for every element $z$, whereas I need to consider the whole sum (and would not be correct element-wise).
    \item MultiSet notation: writing $v, w$ vs writing $\MultiSet(v), \MultiSet(w)$. And when we discuss the domain of $function(v)$.
    \item Stability relation in the Rust code (Slack discussions).
    \item Triangle inequality.
    \item Hint and sensitivity (Excel sheet).
    \item Repeating the proof for Hamming distance: is what we do enough or should we do it in full and self-contained?
    \item (Small) Include code snippet? (for unification purposes)
    \item Constructors.
\end{itemize}



\end{document}
