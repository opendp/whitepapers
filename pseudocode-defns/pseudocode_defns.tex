\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
    %linktoc=none
}

\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}
\newtheorem*{theorem-non}{Theorem}

\theoremstyle{definition}
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}[section]
\newtheorem{observation}{Observation}
\newtheorem{note}{Note}
\newtheorem{hope}{Hope}
\newtheorem{warning}{Warning}
\newtheorem{problem}{Problem}
\newtheorem{fear}{Fear}
\newtheorem{question}{Question}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\A}{\mathbb{A}}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\MultiSets}{\mathrm{MultiSets}}
\newcommand{\MultiSet}{\mathrm{MultiSets}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{d_{in}}
\newcommand{\dout}{d_{out}}
\newcommand{\Relation}{\mathrm{Relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\horizline}{\noindent\rule{\textwidth}{1pt}}


\newcommand{\silvia}[1]{{ {\color{blue}{(silvia)~#1}}}}
\newcommand{\grace}[1]{{ {\color{purple}{(grace)~#1}}}}
\newcommand{\connor}[1]{{ {\color{teal}{(connor)~#1}}}}
\newcommand{\sfi}{}%{\text{\textcolor{olive}{(Salil's feedback incorporated.)}}}
\newcommand{\todosfi}{\todo{Add Salil's feedback.}}

\newcommand{\metricDefn}[1]{The definition of \emph{#1} in the ``proof definitions'' document tells how the distance between data is calculated.}

\newcommand{\inRust}[2]{See \url{#2}.}
\newcommand{\inOpenDPRust}[2]{In OpenDP (Rust), this is called \texttt{#1}. See \url{#2}.}
\newcommand{\inPython}[2]{In Python, this is called \texttt{#1}. See \url{#2}.}
\newcommand{\questionc}[1]{\textcolor{red}{\textbf{Question:} #1}}
\newcommand{\questionr}[1]{\textcolor{blue}{\textbf{Question for reviewers:}}\textcolor{red}{~#1}}
\newcommand{\T}{\texttt{T}}
\newcommand{\data}{\texttt{data}}
\newcommand{\todo}{{\textcolor{red}{TODO: }}}
\newcommand{\todonei}{{\textcolor{red}{TODO (future -- not enough info yet): }}}
\newcommand{\iffText}{\text{if and only if}}
\newcommand{\domainType}[1]{This domain has type \texttt{#1}.}


\title{List of definitions used in the pseudocode}
\author{S\'ilvia Casacuberta, Grace Tian, and Connor Wagaman}
\date{June--July 2021}

\begin{document}

\maketitle

We use the following guideline: if a term appears in the preconditions \& pseudocode section of a proof document, then this term is defined in the ``List of definitions used in the pseudocode" document. Otherwise, it appears in the ``List of definitions used in the proofs" document. 

We maintain the terms in alphabetical order within each section. ``TODOs'' should be included at the end of the corresponding section. On the other hand, ``TODOs'' which better specify an already-defined term should be included immediately following the definition of that term. Examples should never be part of the definition, but we encourage their use right after the definition of a term.

We also recommend linking to the Rust Standard Library when the term is defined there.

\tableofcontents

\section*{List of terms that have not yet been added}
\begin{itemize}
    \item The compatibility pairing and subdomains. Compatibility inheritance for subdomains and proof for subdomain traits. But this is awaiting the specific final implementation.
    \item Clarify why we specify vectors for \texttt{SizedDomain}
    \item Add definition of a valid measurement
    \item Double-check newly added definitions, and trait vs function (e.g., \texttt{SaturatingAdd} and \texttt{saturating\_add})
    \item Incorporate corrections from Prof. Vadhan on GitHub
    \item Add type trait \texttt{Laplace Domain}, and the other ones from base Laplace: \texttt{D::Atom}, \texttt{SampleLaplace}, \texttt{Float}, and \texttt{InfCast(D::Atom)}.
    \item Add function \texttt{is\_sign\_negative()} from Laplace
    \item Add function \texttt{.recip()} from Laplace
    \item Add function \texttt{sample\_laplace} (idealized, for now)
    \item Add \texttt{IntDistance}, although Mike said to keep using \texttt{u32} in the pseudocode type signing for now.
    \item Definition of the Rust iterator.
    \item Do we need \texttt{fold}? Maybe always use loops
\end{itemize}

\section{Types}
% any types should be listed here

\begin{note}[A note on \texttt{()} vs. \texttt{[]}] Parentheses, \texttt{()}, are used to create an instance of a domain. Square brackets, \texttt{[]}, are used to describe the type of a domain.

For example, \texttt{AllDomain(i8)} is the domain of all values of type \texttt{i8}. However, the type of \texttt{AllDomain(i8)} -- the domain itself, not the elements of the domain -- is \texttt{AllDomain[i8]}; note the square brackets. This typing style is inspired by the notation used in Python; see \url{https://docs.python.org/3/library/typing.html}.
\end{note}

\begin{definition}[\texttt{bool}]
    The type \texttt{bool} represents a value which can only be either \texttt{True} or \texttt{False}. If a \texttt{bool} is \texttt{cast}ed to an integer, \texttt{True} will be \texttt{1} and \texttt{False} will be \texttt{0}.
\end{definition}

\begin{definition}[\texttt{::Carrier}]
\texttt{SomeDomain::Carrier} is the type of a member in \texttt{SomeDomain}, where \texttt{SomeDomain} is a domain. 

For example, \texttt{AllDomain(T)::Carrier} is $\T$.
\end{definition}

\begin{definition}[\texttt{f32}]$\sfi$
    \texttt{f32} is the Rust 32-bit floating point type. \inRust{f32}{https://doc.rust-lang.org/std/primitive.f32.html}
\end{definition}

\begin{definition}[\texttt{f64}]$\sfi$
    \texttt{f64} is the Rust 64-bit floating point type. \inRust{f64}{https://doc.rust-lang.org/std/primitive.f64.html} 
\end{definition}

\todonei{Add / pointers to  ``binary64‚Äù type defined in IEEE 754-2008.}

\begin{definition}[\texttt{IntDistance}]
\texttt{IntDistance} is equivalent to \texttt{u32}.
\end{definition}

\begin{definition}[\texttt{::NonNull}]
\texttt{SomeDomain::NonNull} is  \grace{TODO} in \texttt{SomeDomain}, where \texttt{SomeDomain} is a domain. 

For example, \grace{TODO}.
\end{definition}

\begin{definition}[\texttt{u32}]$\sfi$
    \texttt{u32} is the Rust 32-bit unsigned integer type. If $v$ is a value of type \texttt{u32}, then we know that $v\in \{0,1,2,\ldots, 2^{32}-1\}$. \inRust{u32}{https://doc.rust-lang.org/std/primitive.u32.html}
\end{definition}

\begin{definition}[\texttt{usize}]
    \texttt{usize} is defined differently on 32-bit and 64-bit machines. This is because the size of this primitive is equal to the number of bytes it takes to reference any location in memory.
    \begin{itemize}
        \item \textbf{32-bit machines:} if \texttt{v} is a value of type \texttt{usize}, then $\texttt{v}\in \{0,1,2,\ldots,2^{32} - 1\}$
        \item \textbf{64-bit machines:} if \texttt{v} is a value of type \texttt{usize}, then $\texttt{v}\in \{0,1,2,\ldots,2^{64} - 1\}$
    \end{itemize}
    \inRust{usize}{https://doc.rust-lang.org/std/primitive.usize.html}
\end{definition}

\begin{definition}[\texttt{Vec[T]}]$\sfi$
    The Rust type \texttt{Vec[T]} consists of ordered lists of type \texttt{T}. For example, if \texttt{T = bool}, then values of type \texttt{Vec[T]} include $\texttt{[], [0], [1], [0, 0],} \ldots$. \inRust{Vec<T>}{https://doc.rust-lang.org/std/vec/struct.Vec.html}
\end{definition}

\horizline

\subsection{Notes, todos, questions}

%\silvia{Discuss: bounded vs lower bound and upper bound}

\todonei{Include info on MPFR, and possibly relate it to our existing definitions of floats.}

\todonei{Define plus, minus, etc. below each type on which they operate. For example, the definition for \texttt{u32} should also include a definition of plus on \texttt{u32}, multiplication on \texttt{u32}, etc.}

\questionr{Should we have a general definition for ``floats'' (and ``integers''?), or is it sufficiently understood what a float is in general?}

\section{Domains}

$\sfi$ A \emph{data domain} is a representation of the set of values on which a metric or function can operate. For example, if a function accepts inputs from the domain \texttt{IntervalDomain(1:u32,17:u32)}, this means that the function can take any input value \texttt{v} of type \texttt{u32} such that \texttt{1 <= v} and \texttt{v <= 17}.

\begin{definition}[\texttt{AllDomain}]$\sfi$
\texttt{AllDomain(T)} is the domain of all values of type $\T$. \domainType{AllDomain[T]}
\end{definition}

For example, \texttt{AllDomain(u32)} is the domain of all values of type \texttt{u32}.


\begin{definition}[\texttt{ImputableDomain}] 
Any domain for which the \texttt{ImputableDomain} trait is implemented for it, has 
\begin{itemize}
    \item an associated type \texttt{NonNull}. \texttt{VectorDomain::NonNull} is the datum type after imputation. 
    \item an imputation function \texttt{impute\_constant} that replaces a null value with a constant or passes a non-null value through
    \item  a function \texttt{is\_null} to check if a value is null
    \item a function \texttt{null} to construct an instance of the domain
\end{itemize}

\end{definition}

\begin{definition}[\texttt{IntervalDomain}] \sfi For any type \texttt{T} with trait \texttt{TotalOrd},\footnote{As of June 28, the OpenDP library requires the weaker condition of partial ordering (implements \texttt{PartialOrd}) instead.} \texttt{IntervalDomain(L:T, U:T)} is the domain of all values \texttt{v} of type \texttt{T} such that \texttt{L <= v} and \texttt{v <= U}, for a type \texttt{T} that has a total ordering (\texttt{T} has trait \texttt{TotalOrd}) and for values \texttt{L <= U} of type \texttt{T}. \domainType{IntervalDomain[T]}
\end{definition}

An important remark is that the Rust implementation of \texttt{IntervalDomain} checks that \texttt{L} $\leq$ \texttt{U}, and returns an error if \texttt{L} $\geq$ \texttt{U}. Therefore, any transformation or measurement that uses \texttt{IntervalDomain} does not need to re-check this constraint and raise a possible exception for it. 

Note that, because both \texttt{L} and \texttt{U} are of type \texttt{T}, there is no need to explicitly pass \texttt{T}; the type \texttt{T} can be inferred. \texttt{IntervalDomain} is defined on any type that implements the trait \texttt{TotalOrd}. For example, \texttt{IntervalDomain(1:u32, 17:u32)} corresponds to a domain that contains all the \texttt{u32} values \texttt{v} such that \texttt{1 <= v} and \texttt{v <= 17}; it has type \texttt{IntervalDomain[u32]}.

\begin{definition}[\texttt{InherentNullDomain}] 
    \texttt{InherentNullDomain(inner\_domain:D)} is the domain of all values of data domain \texttt{inner\_domain} and \texttt{null} values. \domainType{InherentNullDomain[D]}
\end{definition}

\begin{definition}[\texttt{SizedDomain}] $\sfi$
    \texttt{SizedDomain(inner\_domain:D, n:usize)} is the domain of all vectors of length \texttt{n} drawn from domain \texttt{inner\_domain}. \domainType{SizedDomain[D]} \silvia{As discussed on July 19, this is not only for vectors}
\end{definition}

For example, \texttt{SizedDomain(VectorDomain(AllDomain(u32)), n)} is the domain of all vectors of length $\texttt{n}$ with elements of type \texttt{u32}.

\begin{definition}[\texttt{VectorDomain}]
\texttt{VectorDomain(inner\_domain:D)} is the domain of all vectors of elements drawn from domain \texttt{inner\_domain}. 
\domainType{VectorDomain[D]}
\end{definition}

\subsection{Subdomains}

\horizline

\subsection{Notes, todos, questions}
\todonei{Add clampable domain (\texttt{ClampableDomain}) -- waiting until \texttt{TotalOrd} is fully implemented in the OpenDP library.}

\todonei{As of July 20, OpenDP plans to include subdomains (see the Architecture meeting notes for 20/7). We have to include them and prove that they are indeed subdomains. Then in the metric definition it is enough to list the most general domain, since the domain-metric compatibility in inherited. We will add the necessary information here after Mike and Andy have finished the implementation details.}

\begin{theorem}[Domain-metric compatibility inheritance.]
    Given a domain \texttt{D}, for any subdomain \texttt{S} $\subseteq$ \texttt{D}, if \texttt{D} is compatible with metric \texttt{M} then \texttt{S} is compatible with metric \texttt{M}.
\end{theorem}

\silvia{Since it is a theorem, should it be moved to the proof defs doc?}

\todo{Need to add definition for what does it mean to be compatible.}

\section{Traits}
% any traits should be defined here

\begin{definition}[\texttt{Abs}]
    A type \texttt{T} has trait \texttt{Abs} if and only if the absolute value of a value of type \texttt{T} can be taken.
\end{definition}

\begin{definition}[\texttt{Bounded}]
    A type $\T$ has trait \texttt{Bounded} $\iffText$ $\T$ has some upper bound and some lower bound (some smallest possible value and some largest possible value).
\end{definition}

\begin{definition}[\texttt{CheckedMul}]
    A type \texttt{T} has trait \texttt{CheckedMul} if it performs multiplication that returns ``None" if overflowing.
\end{definition}

\begin{definition}[\texttt{DistanceConstant}]
    A type \texttt{TO} has trait \texttt{DistanceConstant(TI)} $\iffText$
    \begin{itemize}
        \item \texttt{TO} has trait \texttt{Mul(Output=TO)} (multiplication can be done with type \texttt{TO})
        \item \texttt{TO} has trait \texttt{Div(Output=TO)} (some form of inverse mapping can be done with type \texttt{TO})
        \item \texttt{TO} has trait \texttt{PartialOrd} (\texttt{TO} has a partial ordering)
        \item \texttt{TO} has trait \texttt{InfCast(TI)}
    \end{itemize}
    \inOpenDPRust{DistanceConstant}{https://github.com/opendp/opendp/blob/main/rust/opendp/src/traits.rs}
\end{definition}

\begin{definition}[\texttt{Domain}]
A type \texttt{T} has trait \texttt{Domain} $\iffText$ it can represent a set of values that make up a domain. The \texttt{Domain} implementation prescribes a type for members of the domain, as well as a method to check if any instance of that type is a member of that domain.
\end{definition}

\begin{definition}[\texttt{ExactIntCast}]
    A type \texttt{TO} has trait \texttt{ExactIntCast(TI)} $\iffText$:
    \begin{enumerate}
    \item It has trait \texttt{MaxConsecutiveInt}.
    \item Every value of type \texttt{TI} can be \texttt{exact\_int\_cast}ed exactly to a value of type \texttt{TO}, as long as the original value of type \texttt{TI} is no smaller than \texttt{get\_min\_consecutive\_int(TO)} and no larger than \texttt{get\_max\_consecutive\_int(TO)}.
    \end{enumerate}
    
    A cast error is returned when the value being \texttt{exact\_int\_cast}ed is greater than \texttt{get\_max\_consecutive\_int(TO)} or less than \texttt{get\_min\_consecutive\_int(TO)}.
\end{definition}

\begin{definition}[\texttt{Float}]
    Generic trait for floating point numbers. 
\end{definition}

\todo{The Float trait adds \texttt{Div<Self, Output = Self>}}. In general, add the dependencies between traits.

\begin{definition}[\texttt{InfCast}]
A type \texttt{TO} has trait \texttt{InfCast(TI)} $\iffText$ every cast from a value of type \texttt{TI} to type \texttt{TO} will result in a value of type \texttt{TO} that is at least as big as the value of type \texttt{TI}.
\end{definition}

\begin{definition}[\texttt{InherentNull}]
A type \texttt{T} has trait \texttt{InherentNull} $\iffText$ type \texttt{T} can hold some value \texttt{null}.

As of July 16, 2021, only \texttt{f32} and \texttt{f64} have the trait \texttt{InherentNull}.
\end{definition}


\begin{definition}[\texttt{MaxConsecutiveInt}]
A type $\T$ has trait \texttt{MaxConsecutiveInt} if and only if there is some maximum nonnegative integer \texttt{i} such that all integers from 0 up to \texttt{i} (inclusive) can be expressed as a value of type $\T$; but such that the next integer that can be expressed by $\T$ is not $\texttt{i}+1$.
\end{definition}

\begin{definition}[\texttt{Metric}]
A type \texttt{T} has trait \texttt{Metric} $\iffText$ it can represent a metric for quantifying distances between values in a set. The \texttt{Metric} implementation additionally prescribes the type to use for representing distances.
\end{definition}

\begin{definition}[\texttt{One}]
    A type $\T$ has trait \texttt{One} $\iffText$ $\T$ has some multiplicative identity element.
\end{definition}

\begin{definition}[\texttt{OptionNull}]
A type \texttt{Option<T>} has trait \texttt{OptionNull} $\iffText$ \texttt{null} can be represented as \texttt{Option<T>} \grace{Check this because not sure if it makes sense.}
\end{definition}


\begin{definition}[\texttt{PartialEq}]
    A type $\T$ has trait \texttt{PartialEq} $\iffText$ $\T$ has some \grace{TODO}
\end{definition}

\begin{definition}[\texttt{PartialOrd}]\label{def:partial}
A type \texttt{T} has trait \texttt{PartialOrd} if for all elements $a, b, c$ of type \texttt{T}, the following properties are satisfied:

%A partial ordering over a data domain is a binary relation $\leq$ such that for all $a, b, c$ in this data domain, the following properties are satisfied.
    \begin{enumerate}
        \item Reflexivity: $a \leq a$,
        \item Antisymmetry: if $a \leq b$ and $b \leq a$ then $a=b$,
        \item Transitivity: if $a \leq b$ and $b \leq c$ then $a \leq c$.
    \end{enumerate}
%The partial ordering relation is denoted by \texttt{PartialOrd}.
\end{definition}

\begin{definition}[\texttt{SaturatingAdd}]
    A type \texttt{T} has trait \texttt{SaturatingAdd} if it performs addition that saturates at the numeric bounds instead of overflowing.
\end{definition}

\begin{definition}[\texttt{TotalOrd}]
    A type \texttt{T} has trait \texttt{TotalOrd} if and only if \texttt{T} has trait \texttt{PartialOrd} and moreover all elements are comparable; that is, for all elements $a, b$ of type \texttt{T}, either $a \leq b$ or $b \leq a$.
    
    %A total ordering over a data domain is a partial ordering  in which any two elements are comparable. That is, along with the three properties given in Definition~\ref{def:partial}, one more property must be satisfied: $a \leq b$ or $b \leq a$.
    
    %The total ordering relation is denoted by \texttt{TotalOrd}.
\end{definition}

\begin{definition}[\texttt{Zero}]
A type $\T$ has trait \texttt{Zero} $\iffText$ $\T$ has some additive identity element.
\end{definition}

\subsection{Math-related definitions}
\begin{definition}[\texttt{Add(Output=T)}]
    A type \texttt{T} has trait \texttt{Add(Output=T)} $\iffText$ addition can be performed between elements of type \texttt{T}, with the result of the addition also being of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{Div(Output=T)}]
    A type \texttt{T} has trait \texttt{Div(Output=T)} $\iffText$ division can be performed between elements of type \texttt{T}, with the result of the division also being of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{Mul(Output=T)}]
    A type \texttt{T} has trait \texttt{Mul(Output=T)} $\iffText$ multiplication can be performed between elements of type \texttt{T}, with the result of the multiplication also being of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{Sub(Output=T)}]
    A type \texttt{T} has trait \texttt{Sub(Output=T)} $\iffText$ subtraction can be performed between elements of type \texttt{T}, with the result of the subtraction also being of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{Sum(Output=T)}]
    A type \texttt{T} has trait \texttt{Sum(Output=T)} if and only if such type can be created by summing up an iterator. This trait is used to implement the \texttt{sum} method on iterators. Types which implement the trait can be generated by the \texttt{sum()} method. 
\end{definition}

\subsection{Traits that need not appear in the preconditions}
\begin{itemize}
    \item \texttt{\textquotesingle static}. Notes: \texttt{\textquotesingle static} is not a type; it is a lifetime name (this is a Rust definition).
    \item \texttt{Clone}
    \item \texttt{Copy}
\end{itemize}

\horizline

\subsection{Notes, todos, questions}

\section{Functions}

\subsection{Functions in the pseudocode language}

\begin{definition}[\texttt{abs}]
    Given an element \texttt{var} of type \texttt{T}, where \texttt{T} must have trait \texttt{Abs}, the function \texttt{abs} reuturns the absolute value of \texttt{var}.
\end{definition}

\begin{definition}[\texttt{assert}] 
    The function \texttt{assert} is followed by an expression. If \texttt{some\_expression} evaluates to \texttt{False}, then \texttt{assert some\_expression} results in an error that prevents the code from proceeding further. \inPython{\texttt{assert}}{https://docs.python.org/3/reference/simple_stmts.html\#the-assert-statement}
\end{definition}

\begin{definition}[\texttt{can\_cast}]
    The function \texttt{can\_cast(type1,type2)} returns $\True$ if and only if no data would be lost by casting from \texttt{type1} to \texttt{type2}. In other words, it returns $\True$ $\iffText$ there is an injection from \texttt{type1} to \texttt{type2}. \inRust{std::convert::TryFrom}{https://doc.rust-lang.org/std/convert/trait.TryFrom.html}
\end{definition}

For example, \texttt{can\_cast(u32,u64)} will return $\True$ because a \texttt{u32} can always be expressed as a \texttt{u64}; conversely, \texttt{can\_cast(u64,u32)} will return $\False$ because a \texttt{u64} could be too big to be expressed as a \texttt{u32}, and then data would be lost.

\begin{definition}[\texttt{cast}]
    \texttt{cast(val:TI, TO)} converts \texttt{val} of type \texttt{TI} to the corresponding \texttt{val} of type \texttt{TO}, and returns \texttt{val} of type \texttt{TO}. Returns an error if the conversion is unsuccessful.
\end{definition}

\begin{definition}[\texttt{checked\_mul}]
     Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Mul(Output=T)}, \texttt{checked.mul(var1, var2)} returns \texttt{var1*var2} if the result does not overflow, and else returns ``None".
\end{definition}


\begin{definition}[\texttt{exact\_int\_cast}]
    This function only works for types \texttt{TO} that have trait \texttt{ExactIntCast(TI)}. For any given \texttt{val} such that \texttt{val} is between \texttt{get\_min\_consecutive\_int(TO)} and \texttt{get\_max\_consecutive\_int(TO)}, then \texttt{exact\_int\_cast(val:TI,TO)} returns the an integer value of type \texttt{TO} equal to the integer value held by  \texttt{val} (which was of type \texttt{TI}); otherwise, a cast error is returned.
\end{definition}

\begin{definition}[\texttt{get\_input\_domain}]
    The function \texttt{get\_input\_domain(function)} returns the input domain of arguments passed to function \texttt{function}.
\end{definition}

\begin{definition}[\texttt{get\_input\_metric}]
    The function \texttt{get\_input\_metric(some\_relation)} returns the input metric used by the relation \texttt{some\_relation}.
\end{definition}

\begin{definition}[\texttt{get\_max\_consecutive\_int}]
    This function is only defined on types $\T$ that have trait \texttt{MaxConsecutiveInt}. The function \texttt{get\_max\_value(T)} returns the maximum nonnegative integer \texttt{i} such that all integers from 0 up to \texttt{i} (inclusive) can be expressed as a value of type $\T$; but such that the next integer that can be expressed by $\T$ is not $\texttt{i}+1$. The return value is of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{get\_max\_value}]
    This function is only defined on types $\T$ that have a total ordering. The function \texttt{get\_max\_value(T)} returns the maximum value that can be expressed by an object of type \texttt{T}. The return value is of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{get\_min\_consecutive\_int}]
    This function is only defined on types $\T$ that have trait \texttt{MinConsecutiveInt}.   \texttt{get\_max\_value(T)} returns the minimum negative integer \texttt{i} such that all integers from 0 down to \texttt{i} (inclusive) can be expressed as a value of type $\T$; but such that the next integer that can be expressed by $\T$ is not $\texttt{i}-1$. The return value is of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{get\_min\_value}]
    This function is only defined on types $\T$ that have a total ordering. The function \texttt{get\_min\_value(T)} returns the minimum value that can be expressed by an object of type \texttt{T}. The return value is of type \texttt{T}.
\end{definition}

\begin{definition}[\texttt{get\_output\_domain}]
    The function \texttt{get\_output\_domain(function)} returns the output domain of values returned by function \texttt{function}.
\end{definition}

\begin{definition}[\texttt{get\_output\_metric}]
    The function \texttt{get\_output\_metric(some\_relation)} returns the output metric used by the relation \texttt{some\_relation}.
\end{definition}

\begin{definition}[\texttt{has\_trait}]
    The function \texttt{has\_trait(T,(trait1,trait2,...))} is a function that returns $\True$ $\iffText$ the type \texttt{T} implements \texttt{trait1}, \texttt{trait2}, etc.
\end{definition}

\begin{definition}[\texttt{inf\_cast}]
    This function is only defined for casting to types \texttt{TO} that have trait \texttt{InfCast(TI)}. The function \texttt{inf\_cast(val:TI, TO)} casts \texttt{val} to a value of type \texttt{TO} and returns that value. Specifically, \texttt{val} will be casted to the value of type \texttt{TO} that is closest to \texttt{val} and at least as large as \texttt{val}. If \texttt{inf\_cast} is not able to cast \texttt{val} to a value of type \texttt{TO} at least as large as \texttt{val}, then an error is returned instead.
    
    \textbf{Property:} \texttt{inf\_cast}ed distances are never less than input distances.
\end{definition}

\begin{definition}[\texttt{is\_instance}]
    The function \texttt{is\_instance(var,T)} returns $\True$ if and only if the variable \texttt{var} is of type \texttt{T}.
\end{definition}



\begin{definition}[\texttt{is\_none}]
    The function \texttt{var.is\_none} returns \texttt{True} if and only if \texttt{var} which is of \texttt{float} is equal to ``None".
\end{definition}

\begin{definition}[\texttt{is\_null}]
    The function \texttt{var.is\_null} returns \texttt{True} if and only if \texttt{var} which is of \texttt{Option<T>} is not equal to ``Null".
\end{definition}

\begin{remark}[Imputable Domain]
To check for nullity, we use \texttt{v.is\_null()} if v is a float, or \texttt{v.is\_none()} if v is an \texttt{Option<T>}. To abstract these functions, we define the \texttt{ImputableDomain} trait to capture both notions of nullity.
\end{remark}

\begin{definition}[\texttt{len}]
    The function \texttt{len(vector\_name)} returns the number of elements in \texttt{vector} \texttt{vector\_name}. Output is of type \texttt{usize}, so the return value $v$ on 32-bit machines is $v\in \{0,1,2,\ldots,2^{32} - 1\}$; likewise, the return value on 64-bit machines is $v\in \{0,1,2,\ldots,2^{64} - 1\}$. \inRust{std::vec::Vec::len}{https://doc.rust-lang.org/std/vec/struct.Vec.html\#method.len}
\end{definition}

\emph{Note: we do not call it \texttt{length} to avoid notational clashes with, for example, the Bounded Sum code.}

\begin{definition}[\texttt{map}]
    A \texttt{map} applies a given function to all the items in an iterable without using an explicit for loop. Hence, \texttt{map(f, iter)} is an iterator that maps the values of \texttt{iter} with \texttt{f}. \inRust{https://doc.rust-lang.org/std/iter/struct.Map.html}.
\end{definition}

\begin{definition}[\texttt{max}]
    The function \texttt{max(var1, var2)} compares \texttt{var1} and \texttt{var2}, and returns the greater of the two values. When \texttt{var1} and \texttt{var2} are equivalent, it returns \texttt{var2}. The return type of \texttt{map} is also an iterator. \inRust{std::cmp::max}{https://doc.rust-lang.org/std/cmp/fn.max.html}
\end{definition}

\begin{definition}[\texttt{min}]
    The function \texttt{min(var1:T, var2:T)} compares \texttt{var1} and \texttt{var2}, and returns the lesser of the two values. When \texttt{var1} and \texttt{var2} are equivalent, it returns \texttt{var1}. \inRust{std::cmp::min}{https://doc.rust-lang.org/std/cmp/fn.min.html}
\end{definition}

\silvia{Max and min definitions should be consistent (type signing). Why are we not requiring \texttt{T} to have total order?}

\begin{definition}[\texttt{saturating\_add}]
    Given two elements \texttt{var1, var2} of type \texttt{T} with trait \texttt{Add(Output=T)}, the function  \texttt{saturating\_add(var1, var2)} returns \texttt{var1+var2} whenever \texttt{var1+var2} $\in$ \texttt{[get\_min\_value(T), get\_max\_value(T)]}. If \texttt{var1+var2} $<$ \texttt{get\_min\_value(T)}, then \texttt{saturating\_add(var1, var2)} $=$ \texttt{get\_min\_value(T)}. Similarly, in the case where \texttt{var1+var2} $>$ \texttt{get\_max\_value(T)}, then \texttt{saturating\_add(var1, var2)} $=$ \texttt{get\_max\_value(T)}. \inRust{std::intrinsics::saturating\_add}{https://doc.rust-lang.org/std/intrinsics/fn.saturating_add.html}
\end{definition}
% i.e., this is clamping

\begin{definition}[\texttt{sum}]
    The \texttt{sum} function adds the items of an iterable and returns their sum.
\end{definition}

\horizline

\subsection{Notes, todos, questions}


\section{Data structures}

\begin{definition}[\texttt{list}]
    A \texttt{list} is a data structure which is a changeable ordered sequence of elements.
\end{definition}

Importantly, we remark that in some occasions in our Python-like pseudocodes we will write \texttt{list} as an equivalent for the Rust \texttt{Vec} in order to maintain a Python-like notation. For this reason, such a \texttt{list} will have type \texttt{Vec(T)} and be considered an element of \texttt{VectorDomain}. We will allow the use of the Rust-like term \texttt{Vec} when type signing the functions in the pseudocode and proving the corresponding domain properties in the proof.

\section{Classes}

\begin{definition}[\texttt{Transformation}]
    We define a \texttt{Transformation} in the following way.
    
    \questionr{Which pseudocode style is preferred for this definition? With preconditions (section \ref{sec:pseudocode-w-preconditions}) or without preconditions (section \ref{sec:pseudocode-wout-preconditions})?}
    
\subsection{Pseudocode with preconditions}
\label{sec:pseudocode-w-preconditions}

\begin{itemize}
    \item \texttt{input\_domain} must have trait \texttt{Domain}
    \item \texttt{output\_domain} must have trait \texttt{Domain}
    \item \texttt{function} must operate on inputs from \texttt{input\_domain}, and it must produce outputs in \texttt{output\_domain}
    \item \texttt{input\_metric} must have trait \texttt{Metric}
    \item \texttt{output\_metric} must have trait \texttt{Metric}
    \item \texttt{stability\_relation} must operate on input metrics equal to \texttt{input\_metric}, and it must operate on output metrics equal to \texttt{output\_metric}
\end{itemize}

\begin{lstlisting}[language=Python]
class Transformation:
    def __init__(self, input_domain, output_domain, function, input_metric, output_metric, stability_relation):
    	
        self.input_domain = input_domain
        self.output_domain = output_domain
        
        self.function = function
        
        self.input_metric = input_metric
        self.output_metric = output_metric
        
        self.stability_relation = stability_relation
\end{lstlisting}
    
\subsection{Pseudocode without preconditions}
\label{sec:pseudocode-wout-preconditions}

\connor{Mike helped a lot with this definition, so I'm hopeful it's fully correct, or at least very close.}
\begin{lstlisting}[language=Python]
class Transformation:
    def __init__(self, input_domain, output_domain, function, input_metric, output_metric, stability_relation):
    	
        assert has_trait(input_domain, Domain)
        self.input_domain = input_domain
        assert has_trait(output_domain, Domain)
        self.output_domain = output_domain
        
        assert get_input_domain(function) == input_domain
        assert get_output_domain(function) == output_domain
        self.function = function
        
        assert has_trait(input_metric, Metric)
        self.input_metric = input_metric
        assert has_trait(output_metric, Metric)
        self.output_metric = output_metric
        
        assert get_input_metric(stability_relation) == input_metric
        assert get_output_metric(stability_relation) == output_metric
        self.stability_relation = stability_relation
\end{lstlisting}
    
    \inOpenDPRust{Transformation}{https://github.com/opendp/opendp/blob/35dbdc73d7d74e049f5101a704d4e036bed365e8/rust/opendp/src/core.rs\#L369-L376} When we refer to a \textit{valid transformation} in the proofs, this is the precise definition.
\end{definition}

Therefore, there is no need to include the following code snippet in all of the pseudocodes:
\begin{lstlisting}[language=Python]
class Transformation:
    input_domain
    output_domain
    function
    input_metric
    output_metric
    stability_relation 
\end{lstlisting}

\todo{Add the equivalent for Measurements. (Very similar; just change names)}

\section{Metrics}
\subsection{Dataset metrics}
Metrics are used to measure the distances between data. Metrics have a \emph{domain} on which the metric can measure distance, and an \emph{associated type} that determines the type used to represent the distance between datasets.

\textbf{Example:} \texttt{SymmetricDistance} has a domain of \texttt{VectorDomain(AllDomain(T))}, which means that \texttt{SymmetricDistance} can be used to measure the distance between any objects that are vectors of elements of type \texttt{T}. \texttt{SymmetricDistance} has an associated type of \texttt{u32}, which means that a \texttt{u32} value is used to report the distance.

\begin{definition}[\texttt{AbsoluteDistance(T)}]
\metricDefn{absolute distance}
\begin{itemize}
    \item \textbf{Domain:} \texttt{AllDomain(T)}, where \texttt{T} has the trait \texttt{Sub(Output=T)}.
    \item \textbf{Associated type:} \texttt{Q}.
    \item \textbf{$d$-close:} For any two elements $n, m$ in \texttt{AllDomain(T)}, where \texttt{T} denotes an arbitrary type with trait \texttt{Sub(Output=T)}, and $d$ of generic type \texttt{Q}, we say that $n, m$ are $d$-close under the absolute distance metric (abbreviated as $d_{Abs}$) whenever
    \[
        d_{Abs}(n, m) = |n-m| \leq d.
    \]
\end{itemize}
\end{definition}

\begin{definition}[\texttt{SymmetricDistance}]
\metricDefn{symmetric distance} 
\begin{itemize}
    \item \textbf{Domains:} \texttt{VectorDomain(inner\_domain)} where \texttt{inner\_domain} is any domain. \silvia{Said on 19/7: for now, list also \texttt{SizedDomain(VectorDomain(inner\_domain))}}
    \item \textbf{Associated type:} \texttt{u32}.
    \item \textbf{$d$-close:} For any two vectors $u, v \in \texttt{VectorDomain(D)}$ and any $d$ of type \texttt{u32}, we say that $u, v$ are $d$-close under the symmetric distance metric (abbreviated as $d_{Sym}$) whenever 
    \[
        d_{Sym}(u, v) = |\MultiSet(u) \Delta \MultiSet(v)| \leq d.
    \]
\end{itemize}
\end{definition}

\emph{Note: the associated type of \texttt{SymmetricDistance} is hard-coded as \texttt{u32}, so when declaring that the metric being used is \texttt{SymmetricDistance}, we only need to write \texttt{metric = SymmetricDistance()}; by contrast, we need to write \texttt{AbsoluteDistance(T)} where \texttt{T} is the type on which we are taking the absolute distance since the associated type for \texttt{AbsoluteDistance} is not hard-coded.}

\todo{Change to \texttt{IntDistance}.}

\subsection{Sensitivity metrics}

\begin{definition}[\texttt{L1Distance}]

\end{definition}

\begin{definition}[\texttt{L2Distance}]

\end{definition}

\horizline

\subsection{Notes, todos, questions}
\questionc{Add symmetric difference?}

\connor{I don't think we need to. It is not a \texttt{$\backslash$texttt\{...\}} term.}

\todo{Need to learn how to cross-reference TeX files. After Prof. Vadhan's comment on 19/7, we should think of a systematic way to do dependency tracking.}

\todo{Add compatibility pairing as described in the July 20 architecture meeting.}

\end{document}
