\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xurl}

%---- added for warning box
\usepackage{tcolorbox}
%----- end of "added for warning box"


\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
}

\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}

\theoremstyle{definition}
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\newtheorem{observation}{Observation}
\newtheorem{note}{Note}
\newtheorem{hope}{Hope}
\newtheorem{warning}{Warning}
\newtheorem{problem}{Problem}
\newtheorem{fear}{Fear}
\newtheorem{question}{Question}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\A}{\mathbb{A}}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\MultiSet}{\mathrm{MultiSet}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{\texttt{d\_in}}
\newcommand{\dout}{\texttt{d\_out}}
\newcommand{\Relation}{\texttt{relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\U}{\texttt{U}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\function}{\texttt{function}}
\newcommand{\float}{\texttt{float }}
\newcommand{\questionc}[1]{\textcolor{red}{\textbf{Question:} #1}}

\newcommand{\silvia}[1]{{ {\color{blue}{(silvia)~#1}}}}
\newcommand{\grace}[1]{{ {\color{purple}{(grace)~#1}}}}
\newcommand{\connor}[1]{{ {\color{teal}{(connor)~#1}}}}

\newcommand{\todo}{{\textcolor{red}{TODO }}}


\title{Privacy Proofs for OpenDP: Bounded Sum with Known $n$}
\author{S\'ilvia Casacuberta, Grace Tian, Connor Wagaman}
\date{Version as of \today~(UTC)}

\begin{document}

\maketitle

\tableofcontents

\bigskip

\begin{tcolorbox}
\begin{warning}[Proof only applies to integer types]
Please note that this proof only applies for bounded sums calculated on integers. Specifically, the user-specified type \texttt{T} (more details on \texttt{T} can be found in section \ref{sec:pseudocode}) must be an integer type, such as \texttt{u32} or \texttt{i64}.

Other types should be used with caution; for example, we know that the current implementation does not work for floats.
\end{warning}
\end{tcolorbox}

\section{Versions of definitions documents}
\label{sec:versioned-docs}

When looking for definitions for terms that appear in this document, the following versions of the definitions documents should be used.

\begin{itemize}
    \item \textbf{Pseudocode definitions document:} This proof file uses the version of the pseudocode definitions document available as of September 6, 2021, which can be found at \href{https://github.com/opendp/whitepapers/blob/f8b279ab249934182f306138fa14e6390ddae3e9/pseudocode-defns/pseudocode_defns.pdf}{this link} (archived \href{https://web.archive.org/web/20210906201546/https://raw.githubusercontent.com/opendp/whitepapers/pseudocode-defns/pseudocode-defns/pseudocode_defns.pdf}{here}).
    
    \item \textbf{Proof definitions document:} This file uses the version of the proof definitions document available as of September 6, 2021, which can be found at \href{https://github.com/opendp/whitepapers/blob/d4c24e55cc37878634fec0b7f5c89259a3ad3ded/proof-defns/proof_defns.pdf}{this link} (archived \href{https://web.archive.org/web/20210906201056/https://raw.githubusercontent.com/opendp/whitepapers/proof-defns/proof-defns/proof_defns.pdf}{here}). 
\end{itemize}

\section{Current discrepancies between the Rust implementation and the proof}

To guarantee the correctness of the proof, we highlight the discrepancies that this pseudocode and proof have with respect to the actual Rust implementation:
\begin{itemize}
    \item The pseudocode implementation makes the necessary checks with \texttt{checked\_mul} to avoid overflow issues when computing the stability relation. 
    \item The Rust code does not impose the restriction for \texttt{T} to be an integer type. As noted in the initial warning, the current stability relation only guarantees correctness for integer types.
    \item The Rust code uses the stability relation $\dout \geq \din \cdot (\texttt{U}-\texttt{L})/2$ instead of the relation found in the pseudocode, namely $2\cdot \dout \geq \texttt{inf\_cast}(\din, T)\cdot (\texttt{U}-\texttt{L})$. There is already a PR to resolve this discrepancy: \url{https://github.com/opendp/opendp/pull/315}.
    \item The Rust code does not check for possible overflow errors when performing the arithmetic operation $\texttt{U}-\texttt{L}$, whereas the current pseudocode includes a \texttt{checked\_sub} for it.
    \item The Rust code does not include an \texttt{inf\_cast} in the stability relation, which is necessary for type correctness, but there is already a PR that resolves this discrepancy: \url{https://github.com/opendp/opendp/blob/493fe87273adca3294551faa927039b755c1756e/rust/opendp/src/trans/sum/mod.rs#L65-L94}.
    \item The previous PR also includes the new user-specified type trait \texttt{InfDiv}, which the current pseudocode does not include.
\end{itemize}

These changes will soon be applied to the Rust code. The pseudocode also uses the variable \texttt{n} instead of Rust's \texttt{size}, which is more conventional for proof writing.


\section{Algorithm Implementation}
\subsection{Code in Rust}
The current OpenDP library contains the transformation \texttt{make\_bounded\_sum\_n} implementing the bounded sum function with known $n$. This is defined in lines 29-49 of the file \texttt{mod.rs} in the Git repository\footnote{Updated on September 20, 2021.} (\url{https://github.com/opendp/opendp/blob/8bbb0fab1da9b86c50235a36d7026189be43b1ab/rust/opendp/src/trans/sum/mod.rs#L29-L49}).

%\begin{figure}[ht]
    %\includegraphics[width=15cm]{bounded_sum_2.png}
    %\centering
    %\label{fig:code}
%\end{figure}

\begin{figure}[ht]
    \includegraphics[width=15cm]{bounded_sum_n_new.png}
    \centering
    \label{fig:code}
\end{figure}

\subsection{Pseudocode in Python}
\label{sec:pseudocode}
We present a simplified Python-like pseudocode of the Rust implementation below. The necessary definitions for the pseudocode can be found in Section \ref{sec:versioned-docs}.

\subsubsection*{Preconditions}
To ensure the correctness of the output, we require the following preconditions:

\begin{itemize}
    \item \textbf{User-specified types:}
    \begin{itemize}
        \item Variable \texttt{n} must be of type \texttt{usize}.
        \item Type \texttt{T} must have traits \texttt{DistanceConstant(IntDistance)}, \texttt{TotalOrd}, \texttt{CheckedMul}, \texttt{CheckNull}, \texttt{Sum(Output=T)}, \texttt{Sub(Output=T)},  and \texttt{ExactIntCast(usize)}.
        \item \texttt{IntDistance} must have trait \texttt{InfCast(T)}. (Note that this bullet point is not needed in this proof, but it is needed in the code so a hint can be constructed; otherwise a binary search would be needed to construct the hint.)
        \item Variables \texttt{U} and \texttt{L} must be of type \texttt{T}, and we must have $\texttt{L} \leq \texttt{U}$.

\end{itemize}
\end{itemize}

\subsubsection*{Postconditions}
\begin{itemize}
    \item Either a valid \texttt{Transformation} is returned or an error is returned.
\end{itemize}

\begin{lstlisting}[language=Python, escapechar=|]
def MakeBoundedSumN(L: T, U: T, n: usize):
    input_domain = SizedDomain(VectorDomain(IntervalDomain(L, U)), n)
    output_domain = AllDomain(T)
    input_metric = SymmetricDistance()|\label{code:symm-dist}|
    output_metric = AbsoluteDistance(T)|\label{code:abs-dist}|
    
    n_ = exact_int_cast(n, T)|\label{code:exact-int-cast}|
    if checked_mul(L, n_).is_none or checked_mul(U, n_).is_none: 
        raise Exception('Potential overflow') |\label{line:max}|
    
    def relation(d_in: u32, d_out: T) -> bool: |\label{line:rel}|
        if checked_mul(2, d_out).is_none or checked_mul(d_in, U-L).is_none
            or checked_sub(U, L).is_none:
            raise Exception('Overflow occurs in the stability relation')
        return 2*d_out >= inf_cast(d_in, T) * (U - L)
    
    def function(data: Vec[T]) -> T: |\label{line:fn}|
        return sum(data) |\label{line:sum}|
    
    return Transformation(input_domain, output_domain, function, input_metric, output_metric, stability_relation = relation)
\end{lstlisting}

\section{Proof}
\subsection{Symmetric Distance}
\begin{theorem}
    For every setting of the input parameters \texttt{(L, U, n)} to \texttt{MakeBoundedSumN} such that the given preconditions hold, \texttt{MakeBoundedSumN} raises an exception (at compile time or run time) or returns a valid transformation with the following properties:
    \begin{enumerate}
        \item \textup{(Appropriate output domain).} For every element $v$ in \texttt{input\_domain}, $\function(v)$ is in \texttt{output\_domain}.
        
        \item \textup{(Domain-metric compatibility).} The domain \texttt{input\_domain} matches one of the possible domains listed in the definition of \texttt{input\_metric}, and likewise \texttt{output\_domain} matches one of the possible domains listed in the definition of \texttt{output\_metric}.
        
        \item \textup{(Stability guarantee).} For every pair of elements \texttt{v}, \texttt{w} in \texttt{input\_domain} and for every pair $(\din, \dout)$,  where $\din$ has the associated type for \texttt{input\_metric} and $\dout$ has the associated type for \texttt{output\_metric}, if $v,w$ are $\din$-close under \texttt{input\_metric} and $\texttt{relation}(\din, \dout) = \True$, then \texttt{function(v)}, \texttt{function(w)} are $\dout$-close under \texttt{output\_metric}.
    \end{enumerate}
\end{theorem}

\begin{proof}
    \textbf{(Part 1 -- appropriate output domain).} In the case of \texttt{MakeBoundedSumN}, this is equivalent to showing that for every vector \texttt{v} in \texttt{SizedDomain(VectorDomain(IntervalDomain (L, U)), n)}, where \texttt{L} and \texttt{U} have type \texttt{T}, \texttt{function(v)} belongs to \texttt{AllDomain(T)}.
    
    The output correctness follows from the overflow check done through the \texttt{checked\_mul} function on line \ref{line:max} and from the type signature of \texttt{function} as defined on line \ref{line:fn}.
    
    % \connor{I recommend including a discussion here of the \texttt{exact\_int\_cast}. You should demonstrate that the checked mul thing does the check that we want it to. In doing that demonstration, it is important to show that the number of rows \texttt{n} is not underestimated. The exact\_int\_cast ensures that. \texttt{exact\_int\_cast} is needed to ensure that our checked mul checks the thing we want it to check}
    
    % \connor{I will add an explanation of the use of exact\_int\_cast in line \ref{code:exact-int-cast} here.}
    
    The check for overflow ensures that \texttt{function(v)} is contained within the interval \texttt{[get\_min\_value(T), get\_max\_value(T)]}, and hence prevents any overflow from occurring in calculating the return value on line \ref{line:sum}. The check for overflow works in the following way: first, the size of the vector on which we are taking the bounded sum is \texttt{exact\_int\_cast}ed to a value \texttt{n\_} of type \texttt{T} so that we can work with it (if \texttt{n} it cannot be casted exactly -- for example, if \texttt{n} falls outside the range of values representable by type \texttt{T} -- a cast error will be returned; we know that the \texttt{exact\_int\_cast} will work because \texttt{T} has trait \texttt{ExactIntCast(usize)}). Then, we do a \texttt{checked\_mul} that multiplies \texttt{n\_} and \texttt{T}, and which returns \texttt{None} if the result overflows. Because \texttt{checked\_mul(L,n\_)} is the minimum possible sum we could get, and because \texttt{checked\_mul(U,n\_)} is the maximum possible sum we could get, we know that if neither of these cases will result in overflow, then no overflow will occur at any step in our calculation of the final answer. If \texttt{None} is returned by the \texttt{checked\_mul}, indicating that overflow can occur, then line~\ref{line:max} will raise an exception for potential overflow.
    
    The type signature on \texttt{function(v)} automatically enforces that \texttt{function(v)} has return type \texttt{T}. Since the Rust code successfully compiles, by the type signature the appropriate output domain property must hold. Otherwise, the code will raise an exception for incorrect input type.
    
    \smallskip
    
    \textbf{(Part 2 -- domain-metric compatibility).} For \texttt{MakeBoundedSumN}, proving this part corresponds to showing that \texttt{SizedDomain(VectorDomain(IntervalDomain (L, U)), n)} is compatible with \texttt{SymmetricDistance()} (see line \ref{code:symm-dist}), and that \texttt{AllDomain(T)} is compatible with \texttt{AbsoluteDistance(T)} (see line \ref{code:abs-dist}).
    The former follows directly from the list of compatible domains in the definition of symmetric distance, as described in the pseudocode definitions document in Section \ref{sec:versioned-docs}. The latter follows directly from the list of compatible domains in the definition of absolute distance, as described in the pseudocode definitions document in Section \ref{sec:versioned-docs}. 
    
    % Flag on the comptaibility of metrics and domains
    
    \iffalse
    \smallskip
    
    \connor{Problem with current stability guarantee. Ideas copied from Slack, so sorry about the formatting.}
    
    \color{teal}
    
    I think if we did ((upper - lower) + 1) / 2, then we'd be in good shape. This is because we want to make sure that our d\_out is big enough (for privacy, it's worse to have d\_out small). Because upper and lower are both ints, the difference will be an int.

    Current relation: Assume (U-L) divisible by 2. Then we're good. Now assume (U-L) not divisible by 2. Then \texttt{(U-L)/2} < (U-L)/2, where \texttt{(U-L)/2} is done on a computer. Uh-oh.

    "+1" relation: Assume (U-L) divisible by 2. Then \texttt{((U-L)+1)/2} = (U-L)/2, so we're good. Now assume (U-L) not divisible by 2. Then ((U-L)+1) divisible by 2, so ((U-L)+1)/2 is greater than the true (U-L)/2, so we're good.
    
    
    Another idea is to do something like ``if upper-lower is odd, do the +1 strategy. If it's even, use the original relation''. Not sure if this conditional structure has any implementation-based advantages or disadvantages, but it'll be a tight bound.
    
    \color{black}
    \connor{End of notes about the current stability guarantee.}
    
    \silvia{We ended up concluding that the best option is to move the constant to the other side -- namely, $2 \cdot \dout \geq \din \cdot (\texttt{U}-\texttt{L})$}.
    \fi
    
    \textbf{(Part 3 -- stability guarantee).} Throughout the stability guarantee proof, we can assume that $\texttt{function(v)}$ and $\texttt{function(w)}$ are in the correct output domain, by the \textit{appropriate output domain property} shown above. 
    
    Since by assumption $\Relation(\din, \dout) = \True$, by the \texttt{MakeBoundedSumN} stability relation (as defined in line~\ref{line:rel} in the pseudocode), we have that $2 \cdot  \dout \geq \texttt{inf\_cast}(\din, \texttt{T})\cdot (U-L)$. This is equivalent to the stability relation $\dout \geq \texttt{inf\_cast}(\din, T)\cdot (U-L)/2$, which is the one we will show in the proof, except that we avoid any possible integer rounding errors by multiplying by 2 instead of dividing. We will also drop the \texttt{inf\_cast} in the rest of the proof, given that it ensures the correct type of $\din$ but does not affect the bounds of the relation. 
    
    Moreover, $\texttt{v}, \texttt{w}$ are assumed to be $\din$-close. By the definition of the symmetric distance metric in the proof definitions document linked in section \ref{sec:versioned-docs}, this is equivalent to stating that $d_{Sym}(v, w) = |\MultiSet(v) \Delta \MultiSet(w)| \leq \din$. Further, applying the histogram notation,\footnote{Note that there is a bijection between multisets and histograms, which is why the proof can be carried out with either notion. For further details, please consult the proof definitions document in section \ref{sec:versioned-docs}.} it follows that
    \[
        d_{Sym}(v, w) = \lVert h_{v} - h_{w}\rVert_1 = \sum_z |h_v(z) - h_w(z)| \leq \din.
    \]
    We want to show that
    \[
        d_{Abs}(\function(v), \function(w)) \leq d_{Sym}(v, w) \cdot \dfrac{\texttt{U-L}}{2}.
    \]
    This would imply that
    \begin{equation}\label{eq:abs1}
        d_{Abs}(\function(v), \function(w)) \leq d_{Sym}(v, w) \cdot \dfrac{\texttt{U-L}}{2} \leq \din \cdot \dfrac{\texttt{U-L}}{2},
    \end{equation}
    and by the stability relation this will imply that
    \begin{equation}\label{eq:abs2}
        d_{Abs}(\function(v), \function(w)) \leq \dout,
    \end{equation}
    as we want to see. 
\end{proof}

\subsection{First proof: using the path property (adjacent pairs approach)}

To show that $d_{Abs}(\function(v), \function(w)) \leq d_{Sym}(v, w) \cdot \frac{\texttt{U-L}}{2}$, we will use the three lemmas described in the section ``The path property of symmetric distance on sized domains" from Section 5.2 in the document \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"}. With these three lemmas, which are applicable to \texttt{MakeBoundedSumN} because \texttt{input\_domain} is a a sized domain and \texttt{input\_metric} is symmetric distance, it suffices to show the following: For all vectors $x, y \in$ \texttt{input\_domain} such that $d_{Sym}(x, y) = 2$, it follows that 
\[
d_{Abs}(\texttt{function}(x), \texttt{function}(y)) \leq \texttt{U} - \texttt{L}.
\]
By Lemma 5.6 from \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"}, we know that vectors $x, y$ only differ on one element, given that, by assumption, $d_{Sym}(x, y) = 2$. Wlog, let this different element be the $k$-th element of $x$ and $y$, where $x_k = \alpha$, $y_k = \beta$ with $\alpha \neq \beta$.\footnote{The first element of a vector is indexed by 0.} Then,
\[
    d_{Abs}(\texttt{function}(x), \texttt{function}(y)) = |\texttt{function}(x) - \texttt{function}(y)| = 
\]
\[
    = \Big|\sum_{i=0}^{\texttt{n}-1}x_i - \sum_{i=0}^{\texttt{n}-1}y_i\Big| = \Big| \sum_{i=0}^{\texttt{n}-1} (x_i - y_i) \Big| = |0 + (x_k - y_k)| = |\alpha - \beta| \leq |\texttt{U-L}| = \texttt{U-L},
\]
since \texttt{U} $\geq$ \texttt{L}. Therefore, applying Lemma 5.7 from \href{https://www.overleaf.com/project/60d214e390b337703d200982}{``List of definitions used in the proofs"}, it follows that \texttt{function} is $($\texttt{U-L}$)/2$-stable. By definition, this implies that for any $v, w \in$ \texttt{input\_domain},
\[
    d_{Abs}(\texttt{function}(v), \texttt{function}(w)) \leq d_{Sym}(v, w) \cdot (\texttt{U-L})/2.
\]
Lastly, by Equations~\ref{eq:abs1} and \ref{eq:abs2} this implies that
\[
    d_{Abs}(\function(v), \function(w)) \leq \dout,
\]
as we want to prove.

%\silvia{Flag: this will be updated to the more general notion of path property (through shortest path metric on a graph), but this matches the current version of the proofs document.}

\newpage

\subsection{Second proof: direct method (all pairs approach)}
\subsubsection{General inequality}
The general statement that we will need to prove is the following. For any elements $a_1, \ldots, a_n \in$ \texttt{[L, U]} and $b_1, \ldots, b_n \in \mathbb{Z}$ such that $\sum_i b_i = 0$, 
\[
    \Big|\sum_i a_ib_i\Big| \leq \dfrac{a_{\max}-a_{\min}}{2} \cdot \Big(\sum_i |b_i| \Big).
\]
Note that this corresponds to the tightest possible \texttt{[L, U]} interval.

Let $u$ denote the vector formed by all the elements of $v$ and $w$ \textit{without multiplicities} (i.e., $u$ contains exactly once each of the elements in $\MultiSet(v) \cup \MultiSet(w)$, in any order). Let $u_i$ denote the $i$-th element of $u$, and similarly for $v$ and $w$, and let $m$ denote \texttt{len}$(u)$.  
Then, by definition,
\[
    d_{Sym}(v, w) = \sum_z \Big|h_v(z) - h_w(z)\Big| = \sum_i \Big|h_v(u_i) - h_w(u_i)\Big|;
\]
\[
    d_{Abs}(\function(v), \function(w)) = \Big|\function(v) - \function(w)\Big| = \Big|\sum_i v_i - \sum_i w_i\Big| = 
\]
\[
   = \Big|\sum_i u_i \cdot h_v(u_i) - \sum_i u_i \cdot h_w(u_i)\Big| = \Big|\sum_i u_i \cdot (h_v(u_i) - h_w(u_i))\Big|.
\]
Because by assumption $v, w \in $ \texttt{input\_domain = SizedDomain(VectorDomain(IntervalDomain (L, U)), n)}, we know that \texttt{len}$(v) =$ \texttt{len}$(w) =$ \texttt{n}. Therefore,

\begin{equation}\label{eq:sum}
    \sum_i (h_v(u_i) - h_w(u_i)) = \texttt{n}-\texttt{n} = 0.
\end{equation}
We now separate the positive values from the negative ones by defining vectors $x, y, \lambda$ and $\mu$ as follows. Let
\[
    h_v(u_{k_1})-h_w(u_{k_1}) \leq \ldots \leq 0 \leq h_v(u_{k_m})-h_w(u_{k_m}) 
\]
be the sequence of the $\{h_v(u_i)-h_w(u_{i})\}$ in increasing order. Let $s$ be the smallest value such that $h_v(u_{k_s})-h_w(u_{k_s})$ is greater or equal to 0 (we set $t=m$ if all the values are negative). Then, we define the vector entries of $x, y, \lambda, \mu$ as
\[
    x_j = h_v(u_{k_{j}})-h_w(u_{k_{j}}),
\]
\[
    \lambda_j = u_{j},
\]
for $s \leq j \leq m$, and
\[
    y_j = h_v(u_{k_{j}})-h_w(u_{k_{j}}),
\]
\[
    \mu_j = u_j
\]
for $0 \leq j < s$.\footnote{It is not necessary that the entries of $x_j$ and $y_j$ are ordered; only that they only contain positive and negative values, respectively, and that the $\lambda$ and $\mu$ values match their corresponding indices.} That is, $x$ contains all of the positive values and $y$ all of the negative ones.

Let $r$ denote the length of vectors $x$ and $\lambda$ as constructed above, and by construction $s$ denotes the length of vectors $y$ and $\mu$ above (where $r+s = m$). Hence we obtain the values $x_1, \ldots, x_r \geq 0$ and $y_1, \ldots, y_s \leq$ for some $r, s \in \mathbb{Z}$, such that
\[
    \sum_i x_i + \sum_j y_j = 0 \quad \textrm{and so} \quad \sum_i x_i = \sum_j |y_j|,
\]
by Equation~\ref{eq:sum}. Then,
\[
    d_{Abs}(\function(v), \function(w)) = \Big|\sum_i u_i \cdot (h_v(u_i) - h_w(u_i))\Big| =
\]
\[
    = |\lambda_1 x_1 + \cdots + \lambda_r x_r + \mu_1 y_1 + \cdots \mu_s y_s| = \Big|\overline{\lambda} \sum_i x_i + \overline{\mu} \sum_j y_j\Big| = 
\]
\[
    = \dfrac{|\overline{\lambda} - \overline{\mu}|}{2} \Big(\sum_i x_i + \sum_j |y_j|\Big) = |\overline{\lambda} - \overline{\mu}| \sum_i x_i,
\]  
where
\[
    \overline{\lambda} = \dfrac{\sum \lambda_i x_i}{\sum x_i}, \quad \overline{\mu} = \dfrac{\sum \mu_j y_j}{\sum y_j} = \dfrac{\sum \mu_j |y_j|}{\sum |y_j|};
\]
i.e., they correspond to the weighted arithmetic mean. 

By definition of the \texttt{input\_domain}, the entries of $v$ and $w$ are contained within the interval \texttt{[L, U]}, and hence $\texttt{U} \geq \max\{\lambda_i, \mu_j\}$ and $\texttt{L} \leq \min\{\lambda_i, \mu_j\}$. Then,
\[
    \dfrac{\texttt{U-L}}{2} \Big(\sum_i x_i + \sum_j |y_j|\Big) = \dfrac{\texttt{U-L}}{2} \cdot 2 \sum_i x_i = (\texttt{U-L}) \sum_i x_i.
\]
Since $|\overline{\lambda} - \overline{\mu}| \leq \texttt{U-L}$, it follows that
\[
    d_{Abs}(\function(v), \function(w)) = \dfrac{\overline{\lambda}-\overline{\mu}}{2}\Big(\sum_i x_i + \sum_j |y_j|\Big) = \dfrac{\overline{\lambda}-\overline{\mu}}{2}\Big(\sum_i x_i - \sum_j y_j\Big) =
\]
\[
    \dfrac{\overline{\lambda}-\overline{\mu}}{2} \Big(\sum_i |h_v(u_i) - h_w(u_i)| \Big) = \dfrac{\overline{\lambda}-\overline{\mu}}{2} \cdot d_{Sym}(v, w) \leq \dfrac{\texttt{U-L}}{2} \cdot d_{Sym}(v, w).
\]
Hence,
\[
    d_{Abs}(\function(v), \function(w)) \leq \dfrac{\texttt{U-L}}{2} \cdot d_{Sym}(v, w),
\]
as we wanted to show.

\end{document}
